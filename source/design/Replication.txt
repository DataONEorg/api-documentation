Member Node Object Replication (Draft Proposal)
==============================================

Replication of objects between Member Nodes (MN) within the DataONE system is
managed by the Coordinating Nodes (CN). CNs are aware of the replication
policies of each object (through system metadata) and the capabilities of each
MN (through node capabilities), and populate a distributed queue of replication
tasks to be processed by all of the CNs.

Replication can be initiated in three ways:

 1) CN synchronization: harvesting of system and science metadata 
 2) CN timed replication: periodic sweep of all system objects 
 3) MN event-based replication: MN sends replication request to a 
    CN (not implemented)

Populating Replication Queues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The CN's Synchronization Service maintains a distributed Hazelcast Map of system
metadata (hzSystemMetadataMap). This map reflects the current state of the
DataONE system's object store. This in-memory map is also bound to the backing
Metacat object store via the Hazelcast MapStore and MapLoader interfaces. The
hzSystemMetadataMap serves as an object-level locking mechanism across CNs, and
any service that will make changes to an object's system metadata will need to
gain a lock on the given object identifier in the map. The hzSystemMetadataMap
is set to be persisted (backed-up) on 3 CNs.

As the CN Synchronization Service becomes aware of create, update, and delete
events for MN objects through harvesting, it populates a Hazelcast queue
(hzReplicationTaskQueue) used to schedule replication tasks. This is done by
calling ReplicationService.createReplicationTaskList(pid). The Replication
Service evaluates the ReplicationPolicy of the given object's system metadata,
evaluates the capabilities and availability of the potential target MNs, and
creates a ReplicationTask for each MN replication target up to the
numberOfReplicas in the object's ReplicationPolicy. Each ReplicationTask is
listed based on priority. The Synchronization Service then iterates through the
returned task list and populates the hzReplicationTaskQueue with the ordered
tasks. Each item offered to the queue consists of a task identifier and a
ReplicationTask.

.. Note::
    TODO: Describe the CN time-based population of the replication task queue
    that periodically does a full sweep of the object store.
    
.. Note::
    TODO: Describe the MN-based replication via a CNReplication API request
    (not implemented)


Processing Replication Queues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
As the hzReplicationTaskQueue is populated, each CN's Replication Service polls
the queue for new tasks to process. Upon receiving a ReplicationTask item from
the queue, a CN Replication Service instance calls handleReplicationTask(),
passing the replicationTask to be handled, to initiate the MN to MN replication.

The CN calls replicate() on the target MN (mnB), passing in the cnZ token
(cnZToken), the originating node reference (mnA), and the identifier of the
object to be replicated (pid). This call triggers the MN (mnB) to call
getReplica() on the originating MN (mnA), passing in mnB token
(mnBToken) and the identifier of the object to be replicated (pid). In turn,
the CN updates the system metadata for the object, setting the ReplicationStatus
to QUEUED after gaining the lock on the object. The lock is immediately
released.

Before responding to getReplica(), mnA checks for replication authorization by
calling isNodeAuthorized() on the CN, passing in the mnA token
(mnAToken), the Subject listed in the mnBToken (mnBSubject), the object
identifier (pid), and the desired replication permission
(replicationPermission). The Replication Service looks up Subject in the
LDAP replication group, and returns the response.

Upon successful authorization, mnA replicates the object (replicaBytes) to the
target MN (mnB). mnB in turn sends a successful replication response to the CN
(replicateResponse). The CN Replication Service once again updates the system
metadata for the object after gaining a lock in the hzSystemMetadataMap. The
lock is immediately released, and the statusResponse is sent to the CN.

.. figure:: images/repl_01.png

*Figure 1.* The CN Synchronization Service populates a replication queue that is
monitored by the Replication Service. The Replication Service in turn populates
a replication task queue based on object and node policies. The service monitors
this queue and initiates replication between two MNs. Upon success, the
objects's system metadata is updated to indicate that replication is complete.

..
  @startuml images/repl_01.png
  skinparam notebordercolor #AAAAAA
  skinparam notefontcolor #222222
  title Replicate an object between two Member Nodes\n\n
  participant "mnA : MNode" as mnA <<MNode>>
  participant "mnB : MNode" as mnB <<MNode>>
  participant "cnXSyncService : SynchronizationService" as cnX <<CNode>>
  participant "cnYReplService : ReplicationService" as cnY <<CNode>>
  participant "cnZReplService : ReplicationService" as cnZ <<CNode>>
  
  == Populate Queues ==
  cnX -> mnA: listObjects()
  activate cnX #D74F57
  activate mnA #D74F57
  mnA --> cnX: objectList
  deactivate mnA
  
  cnX -> mnB: listObjects()
  activate mnB #D74F57
  mnB --> cnX: objectList
  deactivate mnB
  note right
  Each put() to the hz maps and queues below
  concurrently distributes the item across CNs
  in memory and their backing MapStore
  end note
  
  loop 1:size(objectList)
  cnX -> cnX: hzSystemMetadataMap.put(pid, sysmeta)
  end
  cnX -> cnX: cnXReplicationService.createReplicationTaskList(pid)
  loop 1:size(replicationTaskList)
  cnX -> cnX: hzReplicationTaskQueue.put(taskid, replicationTask)
  deactivate cnX
  end
  note right of cnY #lightblue
    TODO: Show timed ReplicationService 
    system metadata sweep and task queue
    population
  end note
  
  note right of cnY #lightblue
    TODO: Show MN-based replication       
    request and task queue population   
  end note
   
  == Process Queues ==
  
  cnY -> cnY: hzReplicationTaskQueue.poll()
  activate cnY #D74F57
  deactivate cnY
  
  note right
  Each ReplicationService
  continuously polls the 
  hz queues
  end note
  
  
  cnZ -> cnZ: hzReplicationTaskQueue.poll()
  activate cnZ #D74F57
  cnZ --> cnZ: replicationTask
  deactivate cnZ
        
  cnZ -> cnZ: handleReplicationTask(replicationTask)
  activate cnZ #D74F57

  cnZ -> mnB: replicate(cnZToken, mnA, pid)
  activate mnB #D74F57
  cnZ -> cnZ: setReplicationStatus(pid, ReplicationStatus.QUEUED)
  
  note left
   Object's system metadata get's updated
  end note
  
  cnZ -> cnZ: hzObjectMap.lock(pid)
  cnZ -> cnZ: updateSystemMetadata(pid)
  cnZ --> cnZ: statusResponse
  cnZ -> cnZ: hzObjectMap.unlock(pid)
  
  mnB -> mnA: getReplica(mnBToken, pid)
  deactivate mnB
  activate mnA #D74F57
  mnA -> cnZ: isNodeAuthorized(mnAToken, mnBSubject, pid, replicationPermission)
  cnZ --> mnA: authorizationResponse
  mnA --> mnB: replicaBytes
  deactivate mnA
  activate mnB #D74F57
  mnB --> cnZ: replicateResponse
  deactivate mnB
  
  cnZ -> cnZ: setReplicationStatus(pid, ReplicationStatus.COMPLETE)
  note left
  Object's system metadata get's updated
  end note
  cnZ -> cnZ: hzObjectMap.lock(pid)
  cnZ -> cnZ: updateSystemMetadata(pid)
  cnZ -> cnZ: hzObjectMap.unlock(pid)
  cnZ --> cnZ: statusResponse
  deactivate cnZ
  @enduml
