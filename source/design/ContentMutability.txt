Mutability of Content in DataONE
================================

.. index:: mutability

.. note::

   This document is a draft proposal for supporting the mutable content model
   employed by several institutions wanting to become member nodes in DataONE.
   It incorporates discussions starting from the September 2012 AHM held in
   Albuquerque, the follow-up CCIT teleconference, and CCIT meeting in February
   2013 in Santa Barbara.


.. contents::

Overview
------------

Several institutions wanting to become member nodes in DataONE have existing 
infrastructure employing a mutable content model.  In short, the mutable content 
model is where changes to content overwrite the existing content returned by an 
identifier. DataONE currently follows an immutable content model, whereby member
nodes are required to save any changes to an object as a new object with a new 
identifier which formally obsoletes the previous one.  The challenge is to find
the optimal way to support member nodes using a mutable content model, while 
preserving the reproducibility assurances the current approach offers.


The Problem
-----------
Current DataONE replication processes and fixity checks depend on content 
immutability. Mutable content from a member node cannot be differentiated from
corrupt copies of the object that need to be fixed by recovery from other replicas.
The current immutability requirement helps to ensure repeatability of any use of
an object, meaning that any analysis on a data set repeated sometime in the future
should yield identical results (within the limits of precision of the analytical 
tools).  By overwriting previous version, nodes following the mutable content 
model cannot ensure repeatable retrieval of content.

New features and behaviors are needed in DataONE to work with mutable content.  The
use cases below organize the identified requirements related to mutable content,
with the most relevant use cases listed first.

Use Cases
---------

Prioritized
^^^^^^^^^^^

1. Data preservation
~~~~~~~~~~~~~~~~~~~~
Defined as activities that help ensure continued discoverability and usefulness
and usually in reference to metadata, not data.

- metadata adaptation / improvement
- metadata correction
- absent a "push" notification, users should be able to easily determine if they
  have the most current version of something, and easily and quickly get it.

2. Mutable Content Member Node support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For institutions following a mutable content model:

- Provide a path forward for integrating into DataONE network. 
- Minimize the burden of adaptation to working with versioned content.
- Allow use of their identifiers in DataONE in the context they are familiar with
  (if their identifier always points to the latest, in DataONE it should too)
- Options for maintaining past versions
- Differentiating between incremental internal saves, vs. new revision.

3. Citation support
~~~~~~~~~~~~~~~~~~~~
- avoid unnecessary costs associated with obtaining DOIs for each version
- coordinating citation by a common identifier for citation tracking
- ensuring that the a cited object is the same when accessed as when it was originally used
- ability to cite a version as well as the conceptual object

Optional
^^^^^^^^

4. Support for combined metadata - data objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Some formats combine data with metadata, for example netCDF, so allowing the 
metadata to change without impacting the consistency assessment of the data itself.

- possible solutions include controlling / validating the dimensions of change,
  and enumerating the dimensions of change allowed in the format datatype.
   
5. Support for accumulating datasets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This means supporting data objects that add records over time, either:

- within pre-defined bounds  e.g. "2013 year-to-date"  (the metadata could stay 
  the same, while data changes)
- without pre-defined bounds e.g. "JGoodall primate observation log"?

6. Support for frequently changing / overwritten data
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
What is the best way to version mutable data that frequently changes but may or 
not be use d.  For example a "current time" object, replaced every minute, or 
"current weather radar" that's replaced every 3 hours.

- preserving every version could be very expensive for very little value
- what mechanisms could be employed to minimize the overhead?
  
The underlying dynamic here is the the rate of mutation vs. the rate of synchronization

 
Not Supported
^^^^^^^^^^^^^

7. Supporting 'unrecorded' data streams
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Mutable content can theoretically include things that are live feeds from 
sensors, but are otherwise uncaptured.  

- Should we allow identifiers to resolve to a URL that returns an input stream?  
- Can we prevent it?  
- Can we mark it as the user's responsibility to do the mn.create?


Assessment
----------
Support for mutable content breaks down into 3 mostly orthogonal issues.  First, 
who is responsible for initiating storage of back-versions of content - the submitter, 
the member node, the coordinating node or the end-user who wants to be able to 
point to a consistent object?  Second, what functionality is required to support 
people using citations or otherwise wanting to refer to consistent objects?  
Third, what types of mutable objects can be supported?
 

Version Storage
^^^^^^^^^^^^^^^
Mutable content implies that back-versions of content are not readily available
on the nodes that produce the mutable content. For those wanting an immutable copy,
the most pragmatic, albeit sub-ethical, approach would be to create and submit a 
personal copy of the data, which suggests that DataONE and member nodes should 
offer an alternative.  Some identifier issuers, such as Data Cite, discourage 
generation of new Data Cite identifiers for new versions with trivial changes,
suggesting that if DataONE versions trivial changes, they should all have the 
DOI associated with them.

The current DataONE storage model, through the MN_Storage.update method, places 
responsibility for storing back versions squarely on the submitter. For the nodes
under discussion, it can be assumed that submitters do not have the ability to 
do that, other than saving as separate, unrelated objects with similar names (not 
a realistic approach).  The 3 other options are presented:

Member Node saves versions
  With this option, the member node maintains back-versions of the content under
  unique identifiers, synchronization occurs as normal.  The "mutable" identifier
  would either be the persistent identifier of the first version of that content,
  or is included in the system metadata in a dedicated field ("series
  identifier"), depending on the design of retrieval functionality.  The goal is 
  making that identifier able to direct users to the latest version of the content. 
  (The section on retrieval will go into this in more detail).

  
Coordinating Nodes save versions
  In this scenario, the member node maintains system metadata consistent with 
  the current version of the object, and the coordinating node learns about the
  new version of content during synchronization, and spawns a new version that 
  gets indexed and replicated.  Multiple revisions between synchronization periods
  would not result in multiple new versions - just the latest revision would be
  persisted as a version in DataONE.  This leaves open the possibility of an 
  end user retrieving and working on an unpersisted version.  
  
  During synchronization, the CN would need to recognize the object as a new version
  by comparing the checksum with what's on record, and recognize it as a mutable
  object (instead of a corrupt copy of a static object), before indexing and 
  initiating replication.
  
End-user saves versions:
  In this approach, the latest version is exposed by the member node as a mutable
  object.  Synchronization picks up any changes to the object that would update
  the index, but skips replication.  Static versions are created with an 
  MN_Read.persistVersion(seriesId, checksum) call, that returns either a pid of
  the newly created version, or a "VersionNotAvailable" if the checksum doesn't
  match any versions already spawned, or the current version.  This precautionary
  measure of comparing checksums ensures that the version the end user is requesting
  can be saved off.  The accessPolicy and ownership rights would be inherited from
  the mutable object.
  
  This approach minimizes excessive versions that may or may not be referenced, 
  which could be beneficial for more regularly updated items.  The member node
  would also be involved in creating the version


Retrieval / Citation Support
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Implicit in the support for mutable content is support for retrieval of, or possibly 
just resolution to, the current object bytes by the identifier assigned in the 
originating system.  At a minimum CNs will be required to support calculating 
which is the current version of series of versions and returning it or its 
identifier. This can only be done using either a special identifier or special 
services to indicate the semantics of what is "current".  Additionally, since 
DataONE identifiers have no special formating semantics, those following a citation
will not know by looking at the identifier whether it is referring to a specific
version or the current item, so services will be needed to easily investigate
an entire version series.

Retrieval vs. Resolution
~~~~~~~~~~~~~~~~~~~~~~~~
Because the content of an object is retrieved in a separate call from its system
metadata, use of the mutable identifier for MN Read API calls is troublesome, due
to the fact that the content may be updated between the two calls, and it would
be impossible to tell without recalculating the checksum on the object retrieved
whether the system metadata downloaded corresponds to the content downloaded.  
The correct approach is to use CN.resolve to provide the Object Location List 
for the appropriate version for a given identifier and parameters.  MN Read API 
calls for the version-level identifier from the object location list would then
be called, ensuring consistent results.


Special Services vs. Special Identifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Those making a citation may wish to cite a specific version, or the latest current
version.  Followers of citations may wish to, if given an identifier representing
a specific version, find out what is the latest version. Conversely, if given
a DOI type identifier that navigates to the latest version, they may wish to find
out what the content was at the time of the citation.  If DataONE relied on special
resolution services alone for navigation to the latest, or the version at a 
specific time and date, the needs of the citation follower have been met.  However,
the person making the citation is not able to cite something in the abstract, as
is the case with Dryad's use of DOIs, where the intention is to make a citation
to the latest version of an item.

It is recommended, therefore, that DataONE model special identifiers called 
"series identifiers" to give those making citations to do so for the conceptual
object, rather than just to a specific version.



The Series Identifier Approach
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The proposed solution is to model and implement a "series identifier" along with 
resolution services that would work with series ids ("sids") and pids.  From a 
DataONE perspective, the series identifiers would be assigned to all versions of 
an object, be unique in dataone (assigned to only one version chain), and would
be reserved just as pids - from the same namespace.  This series identifier, once 
assigned to the version chain, would similarly be immutable, and inherited by 
all new versions of the item.   It is also assumed that in order to coordinate 
users to use one identifier for citations, that the cardinality for the citation 
identifier would be 0..1.  The semantics for resolving a sid would be to 
return an object location list for the latest version from the series.

Member Nodes only maintaining the latest version of an item would be required to 
use a new pid for the resulting new version, and modify the system metadata 
appropriately so that the new version can be picked up by synchronization.  A 
new CN method will be available for MNs to notify CNs what versions are no longer 
available at that node, whereupon replication will determine the new authoritative 
node and replicate the content to the required number of replicas.

It cannot be assumed that a user with an identifier in hand knows whether it is 
a sid or a pid, so DataONE expects the user to refer to the system metadata once 
it has the item to determine if the identifier used in resolve matches the pid 
or the sid.  Similarly, they could interrogate the search results for the same 
information.  For high-level interfaces, like D1Client.getD1Object(id), the pid 
of the object returned may or may not match the passed in 'id'.  So, high-level 
functions or applications that use resolve will have to make sure they handle 
the new resolving semantics.

It is also recommended that search indexes create a search result record for the
series identifier (that would match  the latest version search record).  This 
could complicate searches, so including an "also-known-as" field in the search
result records might serve the purpose of indicating when two result records are 
actually the same thing.


Semantics of "Current"
~~~~~~~~~~~~~~~~~~~~~~
DataONE will need to define what to return when the latest version is not "current", 
i.e. it's archived.  As a starting point, it is safe to assume that when the 
latest is archived, it is the intention of the archiver that no content is returned 
from a "get current" request.  Resolution services, on the other hand, may need 
to return the latest version, whether current or not.


Types of Mutable Objects
^^^^^^^^^^^^^^^^^^^^^^^^
As illustrated in the later use cases, the rate and regularity of change of 
objects can be widely variable.  The more frequent the change, the less likely
that all versions would need to be reproduced, and the utility of complete version
storage diminishes.  One can imagine a "version upon read" 


=======================================


Notes and other Tailings
------------------------

Despite some changes not requiring versioning, organizations employing a 
mutable content model do so for all types of content, including data and 
resource maps, where all changes have to be considered significant.  So the 
question remains: how to ensure reproducibility of use for mutable content, 
or conversely, how to communicate to potential users that reproducibility is 
not assured?  



Related development plans
-------------------------
Regardless of how the mutable content issue is resolved, DataONE will be 
providing a new CN service for navigating to the latest version of an object, 
since the only way to do it currently is for the clients to serially retrieve 
the metadata for versions in the chain until they reach the head version, 
which is very inefficient. A new method to retrieve the entire version history 
is also under consideration.



Workspace oriented member nodes 
-------------------------------
Original thinking about member nodes are as the originators of selected versions 
of reviewed content.  That is, not every intermediate save on the way to a final
product should be saved for future reference.  Organizations following the mutable 
content model for storage do not necessarily have to make this distinction, but
if the member node itself is operating as the workspace, where draft content is
worked on until it is presentable form, this may complicate the original issue of 
what should be made available.

Such potential member nodes may wish to introduce in their native interface
the concept of a "publish" or "export" step that would distinguish between draft 
versions that should not be made available, and those that are published / exported.
This may be useful regardless of how the main issue of mutable content handling 
resolves, simply to keep internal drafts from wider distribution.


Implementation Approaches
-------------------------

Some implementation scenarios from the September, 2012 AHM are described below 
along with some observations on implications for DataONE and it's stakeholders. 
Not all are relevant to the above discussion.


A. No Change
~~~~~~~~~~~~

No changes are made to the DataONE infrastructure, all content remains
immutable, any changes require generation of new object(s) and associated
identifier(s).

Observations:

- Zero direct cost to DataONE (implied indirect costs through loss of
  potential member nodes)

- Implementation more difficult for member nodes, since any change requires
  generation of a new object, new resource map and associated identifiers.

- End users not directly exposed to content updates since these can only be
  retrieved through the indirect approach of traversing the obsolescence path
  (Would probably offer a CN.resolveLatest() to make it a one-stepper)

- End users always receive exactly the same bytes for an object, and thus
  analytical repeatability should be assured (within limits of tools)


B. Internal Copies Maintained by DataONE 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a method such as "UpdateScienceMetadata* is implemented by
CNs and is called by MNs to cause a change to science metadata to be recorded
with no change to identifier. The original science metadata document is
preserved by the CNs, the modified copy is propagated to replica locations,
and future retrieval of the object bytes retrieve the revised version of the
object. An additional API method such as "GetAtTime" may be implemented by the
CNs to retrieve a copy of an object in its state at a specified time. 

Observations:

- API changes required, as are internal changes to CNs to support multiple
  versions of objects per PID

- Onus is on DataONE to maintain previous versions of content

- Recreation of CNs in event of catastrophic failure may not be possible since
  old copies of objects are not maintained outside of the CNs

- API changes required for tier 4 MNs to support overwriting of an existing
  object with a different version

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object


C. Object Differences Preserved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a new class of object ("diff package") is defined to contain
differences between versions of an object. A *diff package* contains all
changes made to a particular object, and thus enables recreation of the object
at any recorded revision. The *diff package* is bound to an object through the
resource map, and is treated like any other object in the system in that it
has a unique identifier, associated system metadata, and may be replicated to
other locations. Since changes are recorded in the *diff package*, it is
necessary for this object to be mutable.

Observations:

- No API signature changes required

- Logic for handling changes to science metadata and diff package mutation
  required

- Additional entry required in resource maps to bind the diff package and
  science metadata

- Convenience methods need to be implemented in libraries to support
  reconstruction of an object state from a diff package

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object

- Diff packages are distributed across the participating nodes, hence CNs can
  be reconstructed in the event of catastrophic failure


D. Two Classes of Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision control system such as Git effectively exposes two different types
of identifier for any object being maintained: the file name of the object;
and the revision identifier for the object. The file name is that typically
exposed and utilized by the end user of the system. The revision identifier
refers to the state of an object at a point in time, and in the case of Git,
is a UUID. Thus in this case the external or "citation" identifier is the file
name, and the internal identifier is the revision UUID.

In the case of DataONE, PIDs are essentially equivalent to Git UUIDs, since
de-referencing a PID will always yield the same set of bytes. There is
currently no equivalent to the concept of a citation identifier in DataONE,
which in some respects is in conflict with the intended use of some types of
identifiers such as DOIs.

Implementing support for two classes of identifier in DataONE would likely
have significant implications, similar to (B) above, but with additional
changes to system metadata to support tracking of multiple identifiers and
revisions for a particular object. It may be feasible to use a time stamp as a
proxy for an object revision identifier, and so this option may simply be a
more general expression of option (B).


E. Two Classes of Objects
~~~~~~~~~~~~~~~~~~~~~~~~~
Objects would be marked as mutable or static, with mutable objects only
indexed, but not replicated.  End users wanting to cite the object would need
to decide whether a static version is needed or whether citing the series
is good enough.  If a static version is needed, the citer would call 
MN.makeVersion(seriesID, checksum) that would create a static copy of the 
content for future reference.  If the checksum passed in didn't match the 
current checksum (or one already saved), it would return a 'VersionNotAvailable'
exception and the end-user would re-download the item, make sure it
was still suitable, and call MN.makeVersion again with the new checksum.

The new version would inherit the accessPolicy, submitter, and rightsHolder fields
of what it is versioning. 

Advantages of this approach are:

- DataONE can remain neutral about identifier semantics and would be
  respecting the citation policy of the originating identifier issuer, like 
  Data Cite.

- DataONE users wanting to cite exact versions could do so

- by returning an exception, end users having out of date content would 
  be properly notified that the content had changed, and be required to 
  reconcile any differences, which is what content owners would want..
 
- Member Nodes would not be required to maintain unnecessary
  back versions. 
 
- this has more potential to work for other types of mutable content, such
  as data objects and resource maps. 
