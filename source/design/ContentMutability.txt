Mutability of Content in DataONE
================================

.. index:: mutability

.. note::

   This document is a draft proposal for supporting the mutable content model
   employed by several institutions wanting to become member nodes in DataONE.
   It incorporates discussions starting from the September 2012 AHM held in
   Albuquerque, the follow-up CCIT teleconference, and CCIT meeting in February
   2013 in Santa Barbara.


.. contents::

Overview
------------

   This document is a draft proposal for supporting the mutable content model
   employed by several institutions wanting to become member nodes in DataONE.
   In short, the mutable content model is where changes to content overwrite the
   existing content returned by an identifier. Currently, DataONE follows an 
   immutable content model, whereby any changes to an object are 'saved as' a 
   new object with a new identifier which formally obsoletes the previous one.  
   Both the difference in how content is associated with identifiers as well as 
   how to maintain past versions of content from this type of node is a barrier 
   to membership in DataONE for such nodes, and lost opportunity for DataONE.

   The current immutability requirement helps to ensure repeatability of any use 
   of an object, meaning that any analysis on a data set repeated sometime in the 
   future should yield identical results (within the limits of precision of the 
   analytical tools).
   
   However, there are practical examples where some changes can, and should be 
   affected to science metadata documents that don't affect reproducibility in a 
   significant way, and where past versions are not merited.  For example:

   - Correction of punctuation or spelling within textual fields such as *Title*
     or *Abstract*

   - Change of policy description such as the license for re-use

   - Providing more appropriate keywords

   - Adding descriptive fields in alternate languages

   - Correcting the name of a data column definition to match the actual name in
     a data file

   - Changing the description of spatial, temporal, taxonomic, or some other
     extent

   - Correcting the description of units used in a data column

   In these situations, having identifiers that always point to the most recently
   updated version of content is convenient for users and helps to promote 
   quality improvements to metadata which further enhances content re-use.

   Despite some changes not requiring versioning, organizations employing a 
   mutable content model do so for all types of content, including data and 
   resource maps, where all changes have to be considered significant.
   
   So the question remains: how to ensure repeatability of use for this content, 
   or conversely, how to communicate to potential users that repeatability is 
   not assured for this object?  Who is ultimately responsible for ensuring 
   repeatable retrieval, the submitter, the member node, the coordinating 
   nodes, or the end-user ?

   Related development plans
   -----------------------------------
   Regardless of how the mutable content issue is resolved, DataONE will be 
   providing a new CN service for navigating to the latest version of an object, 
   since the only way to do it currently is for the clients to serially retrieve 
   the metadata for versions in the chain until they reach the head version, 
   which is very inefficient. A new method to retrieve the entire version history 
   is also under consideration.
   

  Workspace oriented member nodes 
  ----------------------------------------------
  Original thinking about member nodes are as the originators of selected versions 
  of reviewed content.  That is, not every intermediate save on the way to a final
  product should be saved for future reference.  Organizations following the mutable 
  content model for storage do not necessarily have to make this distinction, but
  if the member node itself is operating as the workspace, where draft content is
  worked on until it is presentable form, this may complicate the original issue of 
  what should be made available.  

  Such potential member nodes may wish to introduce in their native interface
  the concept of a "publish" or "export" step that would distinguish between draft 
  versions that should not be made available, and those that are published / exported.
  This may be useful regardless of how the main issue of mutable content handling 
  resolves, simply to keep internal drafts from wider distribution.
  



Implementation Approaches
-------------------------

Some implementation scenarios are described below along with some observations
on implications for DataONE and it's stakeholders.


A. No Change
~~~~~~~~~~~~

No changes are made to the DataONE infrastructure, all content remains
immutable, any changes require generation of new object(s) and associated
identifier(s).

Observations:

- Zero direct cost to DataONE (implied indirect costs through loss of
  potential member nodes)

- Implementation more difficult for member nodes, since any change requires
  generation of a new object, new resource map and associated identifiers.

- End users not directly exposed to content updates since these can only be
  retrieved through the indirect approach of traversing the obsolescence path
  (Would probably offer a CN.resolveLatest() to make it a one-stepper)

- End users always receive exactly the same bytes for an object, and thus
  analytical repeatability should be assured (within limits of tools)


B. Internal Copies Maintained by DataONE 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a method such as "UpdateScienceMetadata* is implemented by
CNs and is called by MNs to cause a change to science metadata to be recorded
with no change to identifier. The original science metadata document is
preserved by the CNs, the modified copy is propagated to replica locations,
and future retrieval of the object bytes retrieve the revised version of the
object. An additional API method such as "GetAtTime" may be implemented by the
CNs to retrieve a copy of an object in its state at a specified time. 

Observations:

- API changes required, as are internal changes to CNs to support multiple
  versions of objects per PID

- Onus is on DataONE to maintain previous versions of content

- Recreation of CNs in event of catastrophic failure may not be possible since
  old copies of objects are not maintained outside of the CNs

- API changes required for tier 4 MNs to support overwriting of an existing
  object with a different version

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object


C. Object Differences Preserved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a new class of object ("diff package") is defined to contain
differences between versions of an object. A *diff package* contains all
changes made to a particular object, and thus enables recreation of the object
at any recorded revision. The *diff package* is bound to an object through the
resource map, and is treated like any other object in the system in that it
has a unique identifier, associated system metadata, and may be replicated to
other locations. Since changes are recorded in the *diff package*, it is
necessary for this object to be mutable.

Observations:

- No API signature changes required

- Logic for handling changes to science metadata and diff package mutation
  required

- Additional entry required in resource maps to bind the diff package and
  science metadata

- Convenience methods need to be implemented in libraries to support
  reconstruction of an object state from a diff package

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object

- Diff packages are distributed across the participating nodes, hence CNs can
  be reconstructed in the event of catastrophic failure


D. Two Classes of Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision control system such as Git effectively exposes two different types
of identifier for any object being maintained: the file name of the object;
and the revision identifier for the object. The file name is that typically
exposed and utilized by the end user of the system. The revision identifier
refers to the state of an object at a point in time, and in the case of Git,
is a UUID. Thus in this case the external or "citation" identifier is the file
name, and the internal identifier is the revision UUID.

In the case of DataONE, PIDs are essentially equivalent to Git UUIDs, since
de-referencing a PID will always yield the same set of bytes. There is
currently no equivalent to the concept of a citation identifier in DataONE,
which in some respects is in conflict with the intended use of some types of
identifiers such as DOIs.

Implementing support for two classes of identifier in DataONE would likely
have significant implications, similar to (B) above, but with additional
changes to system metadata to support tracking of multiple identifiers and
revisions for a particular object. It may be feasible to use a time stamp as a
proxy for an object revision identifier, and so this option may simply be a
more general expression of option (B).


E.  Two Classes of Objects
~~~~~~~~~~~~~~~~~~~~~~~~
Objects would be marked as mutable or static, with mutable objects only
indexed, but not replicated.  End users wanting to cite the object would need
to decide whether a static version is needed or whether citing the series
is good enough.  If a static version is needed, the citer would call 
MN.makeVersion(seriesID, checksum) that would create a static copy of the 
content for future reference.  If the checksum passed in didn't match the 
current checksum (or one already saved), it would return a 'VersionNotAvailable'
exception and the end-user would re-download the item, make sure it
was still suitable, and call MN.makeVersion again with the new checksum.

The new version would inherit the accessPolicy, submitter, and rightsHolder fields
of what it is versioning. 

Advantages of this approach are:

 - DataONE can remain neutral about identifier semantics and would be
   respecting the citation policy of the originating identifier issuer, like Data Cite.

 - DataONE users wanting to cite exact versions could do so

 - by returning an exception, end users having out of date content would 
   be properly notified that the content had changed, and be required to 
   reconcile any differences, which is what content owners would want..
 
 - Member Nodes would not be required to maintain unnecessary
   back versions. 
 
- this has more potential to work for other types of mutable content, such
  as data objects and resource maps. 
