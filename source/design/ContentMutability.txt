Mutability of Content in DataONE
================================

.. index:: mutability

.. note::

   This document is a draft proposal for supporting the mutable content model
   employed by several institutions wanting to become member nodes in DataONE.
   It incorporates discussions starting from the September 2012 AHM held in
   Albuquerque, the follow-up CCIT teleconference, and CCIT meeting in February
   2013 in Santa Barbara.


.. contents::

Overview
------------

Several institutions wanting to become member nodes in DataONE have existing 
infrastructure employing a mutable content model.  In short, the mutable content 
model is where changes to content overwrite the existing content returned by an 
identifier. DataONE currently follows an immutable content model, whereby member
nodes are required to save any changes to an object as a new object with a new 
identifier which formally obsoletes the previous one.  The challenge is to find
the optimal way to support member nodes using a mutable content model, while 
preserving the reproducibility assurances the current approach offers.


The Problem
-----------
Current DataONE replication processes and fixity checks depend on content 
immutability. Mutable content from a member node cannot be differentiated from
corrupt copies of the object that need to be fixed by recovery from other replicas.
The current immutability requirement helps to ensure repeatability of any use of
an object, meaning that any analysis on a data set repeated sometime in the future
should yield identical results (within the limits of precision of the analytical 
tools).  By overwriting previous version, nodes following the mutable content 
model cannot ensure repeatable retrieval of content.

New features and behaviors are needed in DataONE to work with mutable content.  The
use cases below organize the identified requirements related to mutable content,
with the most relevant use cases listed first.

Prioritized Use Cases
---------------------

# Data preservation
  Defined as activities that help ensure continued discoverability and usefulness
  and usually in reference to metadata, not data.
 - metadata adaptation / improvement
 - metadata correction
 - absent a "push" notification, users should be able to easily determine if they
   have the most current version of something, and easily and quickly get it.

# Member node support
  For institutions following a mutable content model:
 - Provide a path forward for integrating into DataONE network. 
 - Minimize the burden of adaptation to working with versioned content.
 - Allow use of their identifiers in DataONE in the context they are familiar with
  - (if their identifier always points to the latest, in DataONE it should too)
 - Options for maintaining past versions
 - Differentiating between incremental internal saves, vs. new revision.

# Citation support: 
 - avoid unnecessary costs associated with obtaining DOIs for each version
 - coordinating citation by a common identifier for citation tracking
 - ensuring that the a cited object is the same when accessed as when it was 
   originally used
 - ability to cite a version as well as the conceptual object


Related Use Cases 
------------------

# support for combined metadata - data objects
  Some formats combine data with metadata, for example netCDF, so allowing the 
  metadata to change without impacting the consistency assessment of the data itself.
  - possible solutions include controlling / validating the dimensions of change,
    and annotating the dimensions of change allowed (which elements are immutable?)
   
# support for accumulating datasets?
  This means supporting data objects that add records over time, either:
 - within pre-defined bounds  e.g. "2013 year-to-date"  (the metadata could stay 
   the same, while data changes)
 - without pre-defined bounds e.g. "JGoodall primate observation log"?

# support for frequently changing / overwritten data
  What is the best way to version mutable data that frequently changes but may or 
  not be used.  For example a "current time" object, replaced every minute, or 
  "current weather radar" that's replaced every 3 hours.
  - preserving every version could be very expensive for very little value
  - what mechanisms could be employed to minimize the overhead?
  
  An underlying dynamic is the the rate of mutation vs. the rate of synchronization
 
Out of Scope
------------
# supporting 'unrecorded' data streams
  Mutable content can theoretically include things that are live feeds from 
  sensors, but are otherwise uncaptured.  Should we allow identifiers to resolve
  to a URL that returns an input stream?  Can we prevent it?  Can we mark it as 
  the user's responsibility to do the mn.create?


Requirements Analysis
----------------------
Support for mutable content breaks down into 3 distinct issues.  First, who is 
responsible for creating back-versions of content - the submitter, the member node,
the coordinating node or the end-user who wants to be able to point to a consistent
object?  Second, what functionality is required to support people using citations
or otherwise wanting to refer to consistent objects?  Third, what types of 
mutable objects can be supported?
 

Versioning
~~~~~~~~~~
Mutable content implies that back-versions of content are not readily available
on the nodes that produce the mutable content. For those wanting an immutable copy,
the pragmatic, albeit perhaps sub-ethical, approach is to create and submit a 
personal copy of the data, which suggests that DataONE and member nodes should 
offer an alternative.  Some identifier issuers, such as Data Cite, discourage 
generation of new Data Cite identifiers for new versions with trivial changes,
suggesting that if DataONE versions trivial changes, they should all have the 
DOI associated with them.

The current DataONE storage model, through the MN_Storage.update method, places 
responsibility for storing back versions squarely on the submitter. For the nodes
under discussion, it can be assumed that submitters do not have the ability to 
do that, other than saving as separate, unrelated objects with similar names (not 
a realistic approach).  The 3 other options are presented:

- Member Node saves versions:
  With this option, the member node maintains back-versions of the content under
  unique identifiers, synchronization occurs as normal.  The "mutable" identifier
  would either be the persistent identifier of the first version of that content,
  or is included in the system metadata in a dedicated field ("series
  identifier"), depending on the design of retrieval functionality.  The goal is 
  making that identifier able to direct users to the latest version of the content. 
  (The section on retrieval will go into this in more detail).

  
- Coordinating Nodes saves versions:
  In this scenario, the member node maintains system metadata consistent with 
  the current version of the object, and the coordinating node learns about the
  new version of content during synchronization, and spawns a new version that 
  gets indexed and replicated.  Multiple revisions between synchronization periods
  would not result in multiple new versions - just the latest revision would be
  persisted as a version in DataONE.  This leaves open the possibility of an 
  end user retrieving and working on an unpersisted version.  
  
  In synchronization, the CN would need to recognize the object as a new version
  by comparing the checksum with what's on record, and recognize it as a mutable
  object (instead of a corrupt copy of a static object), before indexing and 
  initiating replication.
  
- End-user saves versions:
  In this approach, the latest version is exposed by the member node as a mutable
  object.  Synchronization picks up any changes to the object that would update
  the index, but skips replication.  Static versions are created with an 
  MN_Read.persistVersion(seriesId, checksum) call, that returns either a pid of
  the newly created version, or a "VersionNotAvailable" if the checksum doesn't
  match any versions already spawned, or the current version.  This precautionary
  measure of comparing checksums ensures that the version the end user is requesting
  can be saved off.  The accessPolicy and ownership rights would be inherited from
  the mutable object.
  
  This approach minimizes excessive versions that may or may not be referenced, 
  which could be beneficial for more regularly updated items.  The member node
  would also be involved in creating the version

Retrieval / Citation Support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Implicit in the support for mutable content is support for retrieval of, or possibly 
just resolution to, the current object bytes by at least one identifier that can serve 
as a citation identifier.  Accordingly, CNs will be required to support calculating 
which is the current version of something and returning it or its identifier. This 
can only be done using either a special identifier or special services to indicate 
the semantics of what is "current").  With either mechanism, DataONE will need to 
define what to return when the latest version is not "current", i.e. it's archived.
As a starting point, it is safe to assume that when the latest is archived, it is 
the intention of the archiver that no content is returned from a "get current" 
request.  Resolution services, on the other hand, may need to return the latest, 
version, whether current or not.

DataONE will also need to accommodate the notion of a "citable" identifier - one
that may be tied to the semantics of an identifier issuing service, like Data Cite,
or simply refer to the conceptual object, rather than one specific version of it.
The major question is whether to model that identifier separate from the persistent
identifier, or designate one of the existing identifiers as the one to cite, for
example, the pid of the first version, or the earliest pid matching a specific
character pattern.

Option A: Use of special services
---------------------------------
In this scenario, identifiers still only associate with a specific version of the 
content.  Alternative Read API services are used to provide the current version 
of an object. Resource Maps wanting to point to the latest version would use the 
"cn/resolveLatest" URL resource, instead of the current "cn/resolve." Service 
implementation of these services could be as simple as definition of URL query 
parameter "currentVersion" that would apply to CN|MN Read API methods: get, 
getSystemMetadata, getChecksum, describe, and CN Read API methods: resolve, 
search, and query.  (getCurrent, getCurrentSystemMetadata, getCurrentChecksum, 
etc.)

This approach offers 3 advantages over use of special identifiers. First is 
transparency: by using special services implies that the user knows the context 
of the request and will not expect consistent results for repeated requests over
time.  Second is that the identifier for any version can be used to return the 
current version.  Third, and not least, is that the DataONE types schema would 
not need to be altered, triggering the need provide v2 DataONE services.

The use case of having a diverse and uncoordinated user population coordinate 
around one of the version identifiers for citation is the main limitation of 
this approach.  It would be impossible to enforce, and difficult to encourage, 
since the concept of "citation identifier" would not be modeled.  The best DataONE 
could do would be to recommend the best practice of informally designating the 
identifier of the original version as the "citation identifier".  This practice 
would come up short for situations where the identifier to be used for citation 
is not yet issued to the submitter before the object is submitted to DataONE, as 
in the case of a third-party identifier authority.



Option B: Use of Special Identifiers
-----------------------------------------------------
The other option is to model and implement a "series identifier" that could be 
used for (albeit ambiguous) citations.  In this approach, a second identifier 
unique to the version-chain is (optionally) assigned to each object, which can 
be can be used to return the latest version. This series identifier, once 
assigned to the version-chain, would similarly be immutable, and inherited by 
all new versions of the item.  It is also assumed that in order to coordinate 
users to use one identifier for citations, that the cardinality for the citation 
identifier would be 0..1. The 3 main advantages of this approach are:

1. avoiding the need for a new set of API methods called for in option A (but 
  possibly the definition of a CN.setSeriesID() method).
2. flexibility in the timing of assigning the citation identifier.
3. having an identifier that can be used for citations.

The major drawbacks of the special identifier mechanism are:

1. more complicated identifier semantics, since users cannot distinguish between 
  a series identifier and a version-level identifier, resolving the series 
  identifier will return something with a different pid.
2. the limitation of navigating to current versions from only the series 
  identifier, or the need to also define "getLatestVersion" methods.
3. complications to search implementations, where both the version-level 
  identifier and citation-identifier need to have their own search result record.  
  An "also-known-as" field might serve the purpose of indicating when two result 
  records are actually the same thing.








==================


  However, there are practical examples where some changes can,
and should be affected to science metadata documents that don't affect 
reproducibility in a significant way, and where past versions are not merited.  
For example:

- Correction of punctuation or spelling within textual fields such as *Title*
  or *Abstract*

- Change of policy description such as the license for re-use

- Providing more appropriate keywords

- Adding descriptive fields in alternate languages

- Correcting the name of a data column definition to match the actual name in
  a data file

- Changing the description of spatial, temporal, taxonomic, or some other
  extent

- Correcting the description of units used in a data column

In these situations, having identifiers that always point to the most recently
updated version of content is convenient for users and helps to promote 
quality improvements to metadata which further enhances content re-use.

Despite some changes not requiring versioning, organizations employing a 
mutable content model do so for all types of content, including data and 
resource maps, where all changes have to be considered significant.  So the 
question remains: how to ensure reproducibility of use for mutable content, 
or conversely, how to communicate to potential users that reproducibility is 
not assured?  Who is ultimately responsible for producing versions of the content, 
the submitter, the member node, the coordinating nodes, the end-user, or nobody?



Related development plans
-------------------------
Regardless of how the mutable content issue is resolved, DataONE will be 
providing a new CN service for navigating to the latest version of an object, 
since the only way to do it currently is for the clients to serially retrieve 
the metadata for versions in the chain until they reach the head version, 
which is very inefficient. A new method to retrieve the entire version history 
is also under consideration.



Workspace oriented member nodes 
-------------------------------
Original thinking about member nodes are as the originators of selected versions 
of reviewed content.  That is, not every intermediate save on the way to a final
product should be saved for future reference.  Organizations following the mutable 
content model for storage do not necessarily have to make this distinction, but
if the member node itself is operating as the workspace, where draft content is
worked on until it is presentable form, this may complicate the original issue of 
what should be made available.

Such potential member nodes may wish to introduce in their native interface
the concept of a "publish" or "export" step that would distinguish between draft 
versions that should not be made available, and those that are published / exported.
This may be useful regardless of how the main issue of mutable content handling 
resolves, simply to keep internal drafts from wider distribution.


Implementation Approaches
-------------------------

Some implementation scenarios are described below along with some observations
on implications for DataONE and it's stakeholders.


A. No Change
~~~~~~~~~~~~

No changes are made to the DataONE infrastructure, all content remains
immutable, any changes require generation of new object(s) and associated
identifier(s).

Observations:

- Zero direct cost to DataONE (implied indirect costs through loss of
  potential member nodes)

- Implementation more difficult for member nodes, since any change requires
  generation of a new object, new resource map and associated identifiers.

- End users not directly exposed to content updates since these can only be
  retrieved through the indirect approach of traversing the obsolescence path
  (Would probably offer a CN.resolveLatest() to make it a one-stepper)

- End users always receive exactly the same bytes for an object, and thus
  analytical repeatability should be assured (within limits of tools)


B. Internal Copies Maintained by DataONE 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a method such as "UpdateScienceMetadata* is implemented by
CNs and is called by MNs to cause a change to science metadata to be recorded
with no change to identifier. The original science metadata document is
preserved by the CNs, the modified copy is propagated to replica locations,
and future retrieval of the object bytes retrieve the revised version of the
object. An additional API method such as "GetAtTime" may be implemented by the
CNs to retrieve a copy of an object in its state at a specified time. 

Observations:

- API changes required, as are internal changes to CNs to support multiple
  versions of objects per PID

- Onus is on DataONE to maintain previous versions of content

- Recreation of CNs in event of catastrophic failure may not be possible since
  old copies of objects are not maintained outside of the CNs

- API changes required for tier 4 MNs to support overwriting of an existing
  object with a different version

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object


C. Object Differences Preserved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a new class of object ("diff package") is defined to contain
differences between versions of an object. A *diff package* contains all
changes made to a particular object, and thus enables recreation of the object
at any recorded revision. The *diff package* is bound to an object through the
resource map, and is treated like any other object in the system in that it
has a unique identifier, associated system metadata, and may be replicated to
other locations. Since changes are recorded in the *diff package*, it is
necessary for this object to be mutable.

Observations:

- No API signature changes required

- Logic for handling changes to science metadata and diff package mutation
  required

- Additional entry required in resource maps to bind the diff package and
  science metadata

- Convenience methods need to be implemented in libraries to support
  reconstruction of an object state from a diff package

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object

- Diff packages are distributed across the participating nodes, hence CNs can
  be reconstructed in the event of catastrophic failure


D. Two Classes of Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision control system such as Git effectively exposes two different types
of identifier for any object being maintained: the file name of the object;
and the revision identifier for the object. The file name is that typically
exposed and utilized by the end user of the system. The revision identifier
refers to the state of an object at a point in time, and in the case of Git,
is a UUID. Thus in this case the external or "citation" identifier is the file
name, and the internal identifier is the revision UUID.

In the case of DataONE, PIDs are essentially equivalent to Git UUIDs, since
de-referencing a PID will always yield the same set of bytes. There is
currently no equivalent to the concept of a citation identifier in DataONE,
which in some respects is in conflict with the intended use of some types of
identifiers such as DOIs.

Implementing support for two classes of identifier in DataONE would likely
have significant implications, similar to (B) above, but with additional
changes to system metadata to support tracking of multiple identifiers and
revisions for a particular object. It may be feasible to use a time stamp as a
proxy for an object revision identifier, and so this option may simply be a
more general expression of option (B).


E. Two Classes of Objects
~~~~~~~~~~~~~~~~~~~~~~~~~
Objects would be marked as mutable or static, with mutable objects only
indexed, but not replicated.  End users wanting to cite the object would need
to decide whether a static version is needed or whether citing the series
is good enough.  If a static version is needed, the citer would call 
MN.makeVersion(seriesID, checksum) that would create a static copy of the 
content for future reference.  If the checksum passed in didn't match the 
current checksum (or one already saved), it would return a 'VersionNotAvailable'
exception and the end-user would re-download the item, make sure it
was still suitable, and call MN.makeVersion again with the new checksum.

The new version would inherit the accessPolicy, submitter, and rightsHolder fields
of what it is versioning. 

Advantages of this approach are:

- DataONE can remain neutral about identifier semantics and would be
  respecting the citation policy of the originating identifier issuer, like 
  Data Cite.

- DataONE users wanting to cite exact versions could do so

- by returning an exception, end users having out of date content would 
  be properly notified that the content had changed, and be required to 
  reconcile any differences, which is what content owners would want..
 
- Member Nodes would not be required to maintain unnecessary
  back versions. 
 
- this has more potential to work for other types of mutable content, such
  as data objects and resource maps. 
