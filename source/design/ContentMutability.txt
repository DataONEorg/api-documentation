Mutability of Content in DataONE
================================

.. index:: mutability

.. note::

   This document is a draft proposal for supporting the mutable content model
   employed by several institutions wanting to become member nodes in DataONE.
   It incorporates discussions starting from the September 2012 AHM held in
   Albuquerque, the follow-up CCIT teleconference, and CCIT meeting in February
   2013 in Santa Barbara.


.. contents::

Overview
------------

Several institutions wanting to become member nodes in DataONE have existing 
infrastructure employing a mutable content model.  In short, the mutable content 
model is where changes to content overwrite the existing content returned by an 
identifier. DataONE currently follows an immutable content model, whereby member
nodes are required to save any changes to an object as a new object with a new 
identifier which formally obsoletes the previous one.  The challenge is to find
the optimal way to support member nodes using a mutable content model, while 
preserving the reproducibility assurances the current approach offers.


The Problem
-----------
Current DataONE replication processes and fixity checks depend on content 
immutability. Mutable content from a member node cannot be differentiated from
corrupt copies of the object that need to be fixed by recovery from other replicas.
The current immutability requirement helps to ensure repeatability of any use of
an object, meaning that any analysis on a data set repeated sometime in the future
should yield identical results (within the limits of precision of the analytical 
tools).  By overwriting previous version, nodes following the mutable content 
model cannot ensure repeatable retrieval of content.

New features and behavior is needed in DataONE to work mutable content.  The
use cases below organize the identified requirements related to mutable content,
with the most relevant use cases listed first.

Prioritized Use Cases
---------------------

# Data preservation
  Defined as activities that help ensure continued discoverability and usefulness
  and usually in reference to metadata, not data.
 - metadata adaptation / improvement
 - metadata correction
 - absent a "push" notification, users should be able to easily determine if they
   have the most current version of something, and easily and quickly get it.

# Member node support
  For institutions following a mutable content model:
 - Provide a path forward for integrating into DataONE network. 
 - Minimize the burden of adaptation to working with versioned content.
 - Allow use of their identifiers in DataONE in the context they are familiar with
  - (if their identifier always points to the latest, in DataONE it should too)
 - Options for maintaining past versions
 - Differentiating between incremental internal saves, vs. new revision.

# Citation support: 
 - avoid unnecessary costs associated with obtaining DOIs for each version
 - coordinating citation by a common identifier for citation tracking
 - ensuring that the a cited object is the same when accessed as when it was 
   originally used
 - ability to cite a version as well as the conceptual object


Related Use Cases 
------------------

# support for combined metadata - data objects
  Some formats combine data with metadata, for example netCDF, so allowing the 
  metadata to change without impacting the consistency assessment of the data itself.
  - possible solutions include controlling / validating the dimensions of change,
    and annotating the dimensions of change allowed (which elements are immutable?)
   
# support for accumulating datasets?
  This means supporting data objects that add records over time, either:
 - within pre-defined bounds  e.g. "2013 year-to-date"  (the metadata could stay 
   the same, while data changes)
 - without pre-defined bounds e.g. "JGoodall primate observation log"?

# support for frequently changing / overwritten data
  What is the best way to version mutable data that frequently changes but may or 
  not be used.  For example a "current time" object, replaced every minute, or 
  "current weather radar" that's replaced every 3 hours.
  - preserving every version could be very expensive for very little value
  - what mechanisms could be employed to minimize the overhead?
  
  An underlying dynamic is the the rate of mutation vs. the rate of synchronization
 
Out of Scope
------------
# supporting 'unrecorded' data streams
  Mutable content can theoretically include things that are live feeds from 
  sensors, but are otherwise uncaptured.  Should we allow identifiers to resolve
  to a URL that returns an input stream?  Can we prevent it?  Can we mark it as 
  the user's responsibility to do the mn.create?


Requirements Analysis
----------------------
Support for mutable content breaks down into 3 distinct issues.  First, who is 
responsible for creating back-versions of content - the submitter, the member node,
the coordinating node or the end-user who wants to be able to point to a consistent
object?  Second, what functionality is required to support people using citations
or otherwise wanting to refer to consistent objects?  Third, what types of 
mutable objects can be supported?
 

Versioning
~~~~~~~~~~
Mutable content implies that back-versions of content are not readily available
on the nodes that produce the mutable content. For those wanting an immutable copy,
the pragmatic, albeit perhaps sub-ethical, approach is to create and submit a 
personal copy of the data, which suggests that DataONE and member nodes should 
offer an alternative.  Some identifier issuers, such as Data Cite, discourage 
generation of new Data Cite identifiers for new versions with trivial changes,
suggesting that if DataONE versions trivial changes, they should all have the 
DOI associated with them.

The current DataONE storage model, through the MN_Storage.update method, places 
responsibility for storing back versions squarely on the submitter. For the nodes
under discussion, it can be assumed that submitters do not have the ability to 
do that, other than saving as separate, unrelated objects with similar names (not 
a realistic approach).  The 3 other options are presented:

- Member Node saves versions
  With this option, the member node must either adapt their entire storage model
  or if they are working with a third party system, such as DSpace


Support for mutable content amounts support for retrieval of or possibly just 
resolution to the current object bytes by at least one identifier that can serve 
as a citation identifier.  Accordingly, CNs will be required to support calculating 
which is the current version of something and returning it.  DataONE architecture 
also needs to adapt to accomodate the notion of a "citation identifier".  This can 
only be done using either a special identifier or special services to indicate 
the semantics of what is "current").  With either mechanism, DataONE will need 
to define what to return when the latest version is not "current", i.e. it's 
archived.  As a starting point, it is safe to assume that when the latest is 
archived, it is the intention of the archiver that no content is returned from 
a "get current" request.  Resolution services, on the other hand, may need to 
return the latest, whether archived or not.


  However, there are practical examples where some changes can,
and should be affected to science metadata documents that don't affect 
reproducibility in a significant way, and where past versions are not merited.  
For example:

- Correction of punctuation or spelling within textual fields such as *Title*
  or *Abstract*

- Change of policy description such as the license for re-use

- Providing more appropriate keywords

- Adding descriptive fields in alternate languages

- Correcting the name of a data column definition to match the actual name in
  a data file

- Changing the description of spatial, temporal, taxonomic, or some other
  extent

- Correcting the description of units used in a data column

In these situations, having identifiers that always point to the most recently
updated version of content is convenient for users and helps to promote 
quality improvements to metadata which further enhances content re-use.

Despite some changes not requiring versioning, organizations employing a 
mutable content model do so for all types of content, including data and 
resource maps, where all changes have to be considered significant.  So the 
question remains: how to ensure reproducibility of use for mutable content, 
or conversely, how to communicate to potential users that reproducibility is 
not assured?  Who is ultimately responsible for producing versions of the content, 
the submitter, the member node, the coordinating nodes, the end-user, or nobody?



Related development plans
-------------------------
Regardless of how the mutable content issue is resolved, DataONE will be 
providing a new CN service for navigating to the latest version of an object, 
since the only way to do it currently is for the clients to serially retrieve 
the metadata for versions in the chain until they reach the head version, 
which is very inefficient. A new method to retrieve the entire version history 
is also under consideration.



Workspace oriented member nodes 
-------------------------------
Original thinking about member nodes are as the originators of selected versions 
of reviewed content.  That is, not every intermediate save on the way to a final
product should be saved for future reference.  Organizations following the mutable 
content model for storage do not necessarily have to make this distinction, but
if the member node itself is operating as the workspace, where draft content is
worked on until it is presentable form, this may complicate the original issue of 
what should be made available.

Such potential member nodes may wish to introduce in their native interface
the concept of a "publish" or "export" step that would distinguish between draft 
versions that should not be made available, and those that are published / exported.
This may be useful regardless of how the main issue of mutable content handling 
resolves, simply to keep internal drafts from wider distribution.


Implementation Approaches
-------------------------

Some implementation scenarios are described below along with some observations
on implications for DataONE and it's stakeholders.


A. No Change
~~~~~~~~~~~~

No changes are made to the DataONE infrastructure, all content remains
immutable, any changes require generation of new object(s) and associated
identifier(s).

Observations:

- Zero direct cost to DataONE (implied indirect costs through loss of
  potential member nodes)

- Implementation more difficult for member nodes, since any change requires
  generation of a new object, new resource map and associated identifiers.

- End users not directly exposed to content updates since these can only be
  retrieved through the indirect approach of traversing the obsolescence path
  (Would probably offer a CN.resolveLatest() to make it a one-stepper)

- End users always receive exactly the same bytes for an object, and thus
  analytical repeatability should be assured (within limits of tools)


B. Internal Copies Maintained by DataONE 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a method such as "UpdateScienceMetadata* is implemented by
CNs and is called by MNs to cause a change to science metadata to be recorded
with no change to identifier. The original science metadata document is
preserved by the CNs, the modified copy is propagated to replica locations,
and future retrieval of the object bytes retrieve the revised version of the
object. An additional API method such as "GetAtTime" may be implemented by the
CNs to retrieve a copy of an object in its state at a specified time. 

Observations:

- API changes required, as are internal changes to CNs to support multiple
  versions of objects per PID

- Onus is on DataONE to maintain previous versions of content

- Recreation of CNs in event of catastrophic failure may not be possible since
  old copies of objects are not maintained outside of the CNs

- API changes required for tier 4 MNs to support overwriting of an existing
  object with a different version

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object


C. Object Differences Preserved
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this scenario, a new class of object ("diff package") is defined to contain
differences between versions of an object. A *diff package* contains all
changes made to a particular object, and thus enables recreation of the object
at any recorded revision. The *diff package* is bound to an object through the
resource map, and is treated like any other object in the system in that it
has a unique identifier, associated system metadata, and may be replicated to
other locations. Since changes are recorded in the *diff package*, it is
necessary for this object to be mutable.

Observations:

- No API signature changes required

- Logic for handling changes to science metadata and diff package mutation
  required

- Additional entry required in resource maps to bind the diff package and
  science metadata

- Convenience methods need to be implemented in libraries to support
  reconstruction of an object state from a diff package

- User default view is always of the most recent version of an object

- PIDs resolve to the most recent, and presumably most accurate revision of an
  object

- Users may retrieve a copy of an object as it was known at some point in
  time, and thus reproducibility can be assured

- Fixity checking is more difficult since checksums recorded in system
  metadata refer to the latest revision of an object

- Diff packages are distributed across the participating nodes, hence CNs can
  be reconstructed in the event of catastrophic failure


D. Two Classes of Identifier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A revision control system such as Git effectively exposes two different types
of identifier for any object being maintained: the file name of the object;
and the revision identifier for the object. The file name is that typically
exposed and utilized by the end user of the system. The revision identifier
refers to the state of an object at a point in time, and in the case of Git,
is a UUID. Thus in this case the external or "citation" identifier is the file
name, and the internal identifier is the revision UUID.

In the case of DataONE, PIDs are essentially equivalent to Git UUIDs, since
de-referencing a PID will always yield the same set of bytes. There is
currently no equivalent to the concept of a citation identifier in DataONE,
which in some respects is in conflict with the intended use of some types of
identifiers such as DOIs.

Implementing support for two classes of identifier in DataONE would likely
have significant implications, similar to (B) above, but with additional
changes to system metadata to support tracking of multiple identifiers and
revisions for a particular object. It may be feasible to use a time stamp as a
proxy for an object revision identifier, and so this option may simply be a
more general expression of option (B).


E. Two Classes of Objects
~~~~~~~~~~~~~~~~~~~~~~~~~
Objects would be marked as mutable or static, with mutable objects only
indexed, but not replicated.  End users wanting to cite the object would need
to decide whether a static version is needed or whether citing the series
is good enough.  If a static version is needed, the citer would call 
MN.makeVersion(seriesID, checksum) that would create a static copy of the 
content for future reference.  If the checksum passed in didn't match the 
current checksum (or one already saved), it would return a 'VersionNotAvailable'
exception and the end-user would re-download the item, make sure it
was still suitable, and call MN.makeVersion again with the new checksum.

The new version would inherit the accessPolicy, submitter, and rightsHolder fields
of what it is versioning. 

Advantages of this approach are:

- DataONE can remain neutral about identifier semantics and would be
  respecting the citation policy of the originating identifier issuer, like 
  Data Cite.

- DataONE users wanting to cite exact versions could do so

- by returning an exception, end users having out of date content would 
  be properly notified that the content had changed, and be required to 
  reconcile any differences, which is what content owners would want..
 
- Member Nodes would not be required to maintain unnecessary
  back versions. 
 
- this has more potential to work for other types of mutable content, such
  as data objects and resource maps. 
