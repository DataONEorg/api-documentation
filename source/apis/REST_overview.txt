
Overview
~~~~~~~~


- Content is modeled as collections, with :class:`PIDs <Types.Identifier>`
  identifying individual items of a collection.

- The HTTP verbs HEAD, GET, POST, PUT, DELETE are used for retrieving
  information about content, retrieving content, creating content, updating
  content, and deleting content respectively.

- If state information is required (e.g. authentication token), it is passed
  in the HTTP headers.

- Hints to support efficient caching (e.g. content time stamps) should be
  respected. Caching is an important mechanism for achieving scalability.

- Several URL patterns listed below support parameters as key, value pairs.
  Unless otherwise indicted, the key is not case sensitive, though the case of
  the value is significant.

Collections exposed by :term:`Member Node`\s and :term:`Coordinating Node`\s
include:

:``/object``:
  The set of objects available for retrieval from the node.

:``/meta``:
  Metadata about objects available for retrieval from the node.
  
:``/formats``:
  Object formats registered on the node.

:``/log``:
  Log records held on the node.

:``/reserve``:
  Identifiers that have been reserved for future use.

:``/accounts``:
  Principal and ownership related functionality.

:``/sessions``:
  Authenticated session management functions.

:``/node``:
  Service and status information for all nodes on the system.

:``/monitor``: 
  Node health monitoring

:``/replicate``:
  Member node to member node replication functionality


REST Endpoint Summary
~~~~~~~~~~~~~~~~~~~~~

.. include:: generated/generated_rest_summarytable.txt


**Serialization**

The format of the response (except for responses from :func:`MN_read.get` or
:func:`CN_crud.get`) is determined by the ``Accept:`` header provided in the
request. 

The default serialization format is XML and must be supported by all services.

Acceptable content types include:

:``application/json``:
   The response structure is returned as a JSON_ encoded string. The service
   should support an additional parameter "jsonvar" which would cause the
   value of the parameter to be set as a variable name for the resulting JSON
   block (e.g. ``&jsonvar=rs1`` would cause the JSON output to be "rs1=...").

:``text/xml``:

  The response is serialized as XML.

:``application/rdf+xml``:

  The response is serialized in RDF-XML.

:``text/csv``:

  The response is serialized as a comma delimited set of fields, with records
  delimited by a new line.

:``text/html``:

  A HTML rendering of the response.

Regardless of the format, the response is always encoded using the UTF-8
character set.

If the service is not able to provide a response in the specified format, then
the node should return an error code of :exc:`Exceptions.NotImplemented`, with
the HTTP error code set to 406.


.. _JSON: http://www.json.org/


**Parameters in Requests**

Many of the URL patterns described here accept parameters in the URL. Unless
otherwise indicated, parameter names and values are case sensitive.

Parameter names are identical to the parameter names as described in the
corresponding method signature.

Many requests accept an authorization token, i.e. the *token* parameter listed
in method signatures. In all cases, the authorization token will be
transmitted as a HTTP "Authorization" header.

Requests sent using the HTTP POST or PUT verbs must use MIME multipart-mixed
encoding of the message body as described in RFC2046_. In most cases and
unless otherwise indicated, all the parameters except the authorization token
will be sent in the message body (as opposed to URL parameters).

.. _RFC2046: http://tools.ietf.org/html/rfc2046#section-5.1.3


**Authorization Token**

The authorization token is generated in response to an authentication
operation and is used to indicate the principal that is performing the
request. The authorization token is transferred as a value in the HTTP
headers.

The authorization token is serialized in the HTTP headers as indicated::

  Authorization: authorization-token-string

The content of *authorization-token-string* is currently (2010-10-04)
undefined except that it will be a string that may be several kilobytes in
length, but unlikely to be more than 10 kilobytes.

Note that although the HTTP spec does not impose a size limit on HTTP header
entries, practical limits are set by web servers. For example, the default
limit HTTP header field sizes for Apache is `8190 bytes`_.

.. _8190 bytes: http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestfieldsize


Wildcards and Range Operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Several of the REST calls support filtering using wildcards and/or range
operators. When such filtering is supported, it is explicitly noted in the
documentation for a given REST call.

The basic approach is the use of name/value pairs (NVPs) in the URL to
construct a filter for restricting results to a portion of a data set. All
NVPs are combined using the AND operator.

Wildcards are typically supported for string values and allow substring
filters to be specified by including one or more of the following wildcard
characters in the string.

:\*: Match a string of zero or more random characters
:\?: Match a single random character

Range operators are typically supported for values that represent a continuous
series, such as byte sizes and datetimes. A range operator is specified by
appending it to a name. Valid range operators are:

======= ===========================
Suffix  Range Operator
======= ===========================
None    Equals (==) (default)
_eq     Equals (==)
_lt     Less than (<)
_le     Less than or equals (<=)
_gt     Greater than (>)
_ge     Greater than or equals (>=)
======= ===========================

Wildcards and range operators cannot be combined in a single NVP.

**Examples**

Return only objects that have been modified since 6AM on the first of January,
2010 UTC::

  ../object?qt=nvp&lastModified_gt=2010-01-01T06:00:00Z

Return only objects that were last modified in 2005::

  ../object?qt=nvp&lastModified_ge=2005-01-01-T00:00:00Z&lastModified_lt=2006-01-01-T00:00:00Z

.. TODO:: Define the fields that should be supported for filtering for each type of collection.


