
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mutability of Content in DataONE &#8212; v2.2.2</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/dataone.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/mathjax_pre.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script src="../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Identifiers in DataONE" href="PIDs.html" />
    <link rel="prev" title="Replication Overview" href="ReplicationOverview.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="../_static/small_dataone.css" type= "text/css" rel="stylesheet" />

  </head><body>
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PIDs.html" title="Identifiers in DataONE"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ReplicationOverview.html" title="Replication Overview"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html"></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Mutability of Content in DataONE</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mutability-of-content-in-dataone">
<h1><a class="toc-backref" href="#id2">Mutability of Content in DataONE</a><a class="headerlink" href="#mutability-of-content-in-dataone" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<span id="index-0"></span><p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#mutability-of-content-in-dataone" id="id2">Mutability of Content in DataONE</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id3">Overview</a></p></li>
<li><p><a class="reference internal" href="#resolving-series-identifiers" id="id4">Resolving Series Identifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#case-1" id="id5">Case 1</a></p></li>
<li><p><a class="reference internal" href="#case-2" id="id6">Case 2</a></p></li>
<li><p><a class="reference internal" href="#case-3" id="id7">Case 3</a></p></li>
<li><p><a class="reference internal" href="#case-4" id="id8">Case 4</a></p></li>
<li><p><a class="reference internal" href="#case-5" id="id9">Case 5</a></p></li>
<li><p><a class="reference internal" href="#case-6" id="id10">Case 6</a></p></li>
<li><p><a class="reference internal" href="#case-7" id="id11">Case 7</a></p></li>
<li><p><a class="reference internal" href="#case-8" id="id12">Case 8</a></p></li>
<li><p><a class="reference internal" href="#case-9" id="id13">Case 9</a></p></li>
<li><p><a class="reference internal" href="#case-10" id="id14">Case 10</a></p></li>
<li><p><a class="reference internal" href="#case-11" id="id15">Case 11</a></p></li>
<li><p><a class="reference internal" href="#case-12" id="id16">Case 12</a></p></li>
<li><p><a class="reference internal" href="#case-13" id="id17">Case 13</a></p></li>
<li><p><a class="reference internal" href="#case-14" id="id18">Case 14</a></p></li>
<li><p><a class="reference internal" href="#case-15" id="id19">Case 15</a></p></li>
<li><p><a class="reference internal" href="#case-16" id="id20">Case 16</a></p></li>
<li><p><a class="reference internal" href="#case-17" id="id21">Case 17</a></p></li>
<li><p><a class="reference internal" href="#case-18" id="id22">Case 18</a></p></li>
<li><p><a class="reference internal" href="#case-19" id="id23">Case 19</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#referencing-content-by-identifier" id="id24">Referencing Content by Identifier</a></p></li>
<li><p><a class="reference internal" href="#assigning-identifiers" id="id25">Assigning Identifiers</a></p></li>
<li><p><a class="reference internal" href="#limits-on-the-series" id="id26">Limits on the Series</a></p></li>
<li><p><a class="reference internal" href="#requirements-on-member-node-implementations" id="id27">Requirements on Member Node Implementations</a></p></li>
<li><p><a class="reference internal" href="#reassignment-of-authoritativemembernode-field-for-unhosted-versions" id="id28">Reassignment of AuthoritativeMemberNode field for unhosted versions</a></p></li>
<li><p><a class="reference internal" href="#replication-of-unhosted-back-versions" id="id29">Replication of unhosted back-versions</a></p></li>
<li><p><a class="reference internal" href="#synchronizing-content-from-mutable-member-nodes" id="id30">Synchronizing Content from Mutable Member Nodes</a></p></li>
<li><p><a class="reference internal" href="#the-problem" id="id31">The Problem</a></p></li>
<li><p><a class="reference internal" href="#proposal" id="id32">Proposal</a></p></li>
<li><p><a class="reference internal" href="#the-series-identifier" id="id33">The Series Identifier</a></p>
<ul>
<li><p><a class="reference internal" href="#semantics-of-current" id="id34">Semantics of “Current”</a></p>
<ul>
<li><p><a class="reference internal" href="#version-storage" id="id35">Version Storage</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#version-preservation" id="id36">Version preservation</a></p></li>
<li><p><a class="reference internal" href="#working-drafts-vs-repository-publishing" id="id37">Working drafts vs. Repository publishing</a></p>
<ul>
<li><p><a class="reference internal" href="#types-of-mutable-objects" id="id38">Types of Mutable Objects</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#accumulating-datasets" id="id39">Accumulating datasets</a></p></li>
<li><p><a class="reference internal" href="#mixed-metadata-data-objects" id="id40">Mixed metadata-data objects</a></p>
<ul>
<li><p><a class="reference internal" href="#retrieval-citation-support" id="id41">Retrieval / Citation Support</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#retrieval-vs-resolution" id="id42">Retrieval vs. Resolution</a></p></li>
<li><p><a class="reference internal" href="#service-development-plans" id="id43">Service development plans</a></p></li>
<li><p><a class="reference internal" href="#mn-api-method-changes" id="id44">MN API method changes</a></p></li>
<li><p><a class="reference internal" href="#cn-api-method-changes" id="id45">CN API method changes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#use-cases" id="id46">Use Cases</a></p>
<ul>
<li><p><a class="reference internal" href="#prioritized-goals" id="id47">Prioritized goals</a></p>
<ul>
<li><p><a class="reference internal" href="#data-preservation" id="id48">1. Data preservation</a></p></li>
<li><p><a class="reference internal" href="#mutable-content-member-node-support" id="id49">2. Mutable Content Member Node support</a></p></li>
<li><p><a class="reference internal" href="#citation-support" id="id50">3. Citation support</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#optional" id="id51">Optional</a></p>
<ul>
<li><p><a class="reference internal" href="#support-for-frequently-changing-overwritten-data" id="id52">4. Support for frequently changing / overwritten data</a></p></li>
<li><p><a class="reference internal" href="#support-for-accumulating-datasets" id="id53">5. Support for accumulating datasets</a></p></li>
<li><p><a class="reference internal" href="#support-for-mixed-metadata-data-objects" id="id54">6. Support for mixed metadata/data objects</a></p></li>
<li><p><a class="reference internal" href="#supporting-unrecorded-data-streams" id="id55">7. Supporting ‘unrecorded’ data streams</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id3">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>All content synchronized by DataONE is immutable, and so resolution of a
<a class="reference internal" href="../glossary.html#term-persistent-identifier"><span class="xref std std-term">persistent identifier</span></a> (PID) will always result in a pointer (URI) to a set of
bytes that are in all respects identical to the original. Version 2.0 of the
DataONE APIs introduced the ability to associate an optional series identifier
(SID) with an object. Unlike a PID, resolution of a SID will always result in a
pointer (URI) to a set of bytes that represent the latest revision of an object.</p>
<p>A revision or obsolescence chain is constructed by setting the obsoletes and
obsoletedBy properties of the new and old objects respectively. For example,
here PID_B represents the latest revision of object as it obsoletes PID_A
(object PID_A has a value of “PID_B” in its system metadata
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a> property, and object PID_B has a
value of “PID_A” in its system metadata <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a>
property):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+------------+</span>                      <span class="o">+------------+</span>
<span class="o">|</span>            <span class="o">|</span> <span class="o">-----</span> <span class="n">obsoletes</span> <span class="o">---&gt;</span> <span class="o">|</span>            <span class="o">|</span>
<span class="o">|</span>   <span class="n">PID_B</span>    <span class="o">|</span>                      <span class="o">|</span>   <span class="n">PID_A</span>    <span class="o">|</span>
<span class="o">|</span>            <span class="o">|</span> <span class="o">&lt;---</span> <span class="n">obsoletedBy</span> <span class="o">---</span> <span class="o">|</span>            <span class="o">|</span>
<span class="o">+------------+</span>                      <span class="o">+------------+</span>

             <span class="n">resolve</span><span class="p">(</span><span class="n">PID_A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">PID_A</span>
             <span class="n">resolve</span><span class="p">(</span><span class="n">PID_B</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">PID_B</span>
</pre></div>
</div>
<p>In version 1.x of DataONE, it was necessary to manually follow the obsolescence
chain in order to find the latest version of an object. This process is
simplified in version 2.x and later through the use of series identifiers. The
previous example can be augmented with series identifiers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+------------+</span>                      <span class="o">+------------+</span>
<span class="o">|</span>            <span class="o">|</span> <span class="o">-----</span> <span class="n">obsoletes</span> <span class="o">---&gt;</span> <span class="o">|</span>            <span class="o">|</span>
<span class="o">|</span>   <span class="n">PID_B</span>    <span class="o">|</span>                      <span class="o">|</span>   <span class="n">PID_A</span>    <span class="o">|</span>
<span class="o">|</span>   <span class="n">SID_1</span>    <span class="o">|</span>                      <span class="o">|</span>   <span class="n">SID_1</span>    <span class="o">|</span>
<span class="o">|</span>            <span class="o">|</span> <span class="o">&lt;---</span> <span class="n">obsoletedBy</span> <span class="o">---</span> <span class="o">|</span>            <span class="o">|</span>
<span class="o">+------------+</span>                      <span class="o">+------------+</span>

             <span class="n">resolve</span><span class="p">(</span><span class="n">PID_A</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">PID_A</span>
             <span class="n">resolve</span><span class="p">(</span><span class="n">PID_B</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">PID_B</span>
             <span class="n">resolve</span><span class="p">(</span><span class="n">SID_1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">PID_B</span>
</pre></div>
</div>
<p>Each object in the obsolescence chain has the same value for the series
identifier (“SID_1”), and calling <a class="reference internal" href="../apis/CN_APIs.html#CNRead.resolve" title="CNRead.resolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">resolve()</span></code></a> with the value “SID_1”
will result in the URIs from which the object “PID_B” may be retrieved, since
that object is the latest revision in the obsolescence chain.</p>
<p>The availability of PIDs and SIDs means users may now refer to objects using
either a PID when it is necessary or appropriate to refer to an exact set of
bytes that represent an object or through a SID when referring to the latest
version of an object. The former is important for repeatable analyses, since
the same content may be reliably referenced and retrieved. The latter is
important for referencing the most up to date revision of some object, and so
may be useful for example to perform anaysis with the latest information
available.</p>
<p>Unless indicated otherwise, the DataONE version 2.x and later APIs will accept
either a PID or a SID when an identifier is specified as a request parameter.</p>
</div>
<div class="section" id="resolving-series-identifiers">
<h2><a class="toc-backref" href="#id4">Resolving Series Identifiers</a><a class="headerlink" href="#resolving-series-identifiers" title="Permalink to this headline">¶</a></h2>
<p>In a perfect world, all obsolescence chains will have be complete,
bi-directional links, and so determining the latest version of an object is
determined simply by examining the set of all objects with the same SID, and
selecting the object that is not <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> anything else. Obsolescence
chains may be incomplete for various reasons and in such situations, resolution
of series identifiers should still operate consistently.</p>
<p>The following series of scenarios demonstrate the behavior of the DataONE
system when resolving a seriesId to a specific object. The behavior of
resolution is to rely primarily on the obsoletes and obsoletedBy entities,
falling back to the date when an object is added to a Member Node
(<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a>) to determine the newer version.</p>
<p>The following notation is used herein:</p>
<dl class="field-list simple">
<dt class="field-odd"><span class="math notranslate nohighlight">\(P_i\)</span></dt>
<dd class="field-odd"><p>Refers to a Persistent Identifier (PID)</p>
</dd>
<dt class="field-even"><span class="math notranslate nohighlight">\(S_i\)</span></dt>
<dd class="field-even"><p>Refers to a Series Identifier (SID)</p>
</dd>
<dt class="field-odd"><span class="math notranslate nohighlight">\(t_i\)</span></dt>
<dd class="field-odd"><p>The value of <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> for
an object</p>
</dd>
<dt class="field-even"><span class="math notranslate nohighlight">\(t_1\)</span> &lt; <span class="math notranslate nohighlight">\(t_2\)</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(t_1\)</span> is older than <span class="math notranslate nohighlight">\(t_2\)</span></p>
</dd>
<dt class="field-odd"><span class="math notranslate nohighlight">\(P_i \binom{S_j}{t_k}\)</span></dt>
<dd class="field-odd"><p>An object with
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.identifier" title="Types.SystemMetadata.identifier"><code class="xref py py-attr docutils literal notranslate"><span class="pre">identifier</span></code></a> (PID) <span class="math notranslate nohighlight">\(P_i\)</span>, a
<a class="reference internal" href="../apis/Types2.html#v2_0.Types.SystemMetadata.seriesId" title="v2_0.Types.SystemMetadata.seriesId"><code class="xref py py-attr docutils literal notranslate"><span class="pre">seriesId</span></code></a> (SID)
of <span class="math notranslate nohighlight">\(S_j\)</span>, and a <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a>
of <span class="math notranslate nohighlight">\(t_k\)</span>.</p>
</dd>
<dt class="field-even"><span class="math notranslate nohighlight">\(P_i\)</span> <span class="math notranslate nohighlight">\(\rightarrow\)</span> <span class="math notranslate nohighlight">\(P_j\)</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(P_i\)</span> has an <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a>
entry that contains the value <span class="math notranslate nohighlight">\(P_j\)</span></p>
</dd>
<dt class="field-odd"><span class="math notranslate nohighlight">\(P_i\)</span> <span class="math notranslate nohighlight">\(\leftarrow\)</span> <span class="math notranslate nohighlight">\(P_j\)</span></dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(P_j\)</span> has an <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a>
entry that contains the value <span class="math notranslate nohighlight">\(P_i\)</span></p>
</dd>
<dt class="field-even"><span class="math notranslate nohighlight">\(P_i\)</span> <span class="math notranslate nohighlight">\(\leftrightarrows\)</span> <span class="math notranslate nohighlight">\(P_j\)</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(P_i\)</span> has an
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a> entry that
contains the value <span class="math notranslate nohighlight">\(P_j\)</span> and <span class="math notranslate nohighlight">\(P_j\)</span> has an
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a> entry that
contains the value <span class="math notranslate nohighlight">\(P_i\)</span>.</p>
</dd>
<dt class="field-odd"><span class="math notranslate nohighlight">\(P_i\)</span> <span class="math notranslate nohighlight">\(\square\)</span> <span class="math notranslate nohighlight">\(P_j\)</span></dt>
<dd class="field-odd"><p>Neither <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a>
nor <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a> is set by
<span class="math notranslate nohighlight">\(P_i\)</span>  or <span class="math notranslate nohighlight">\(P_j\)</span>.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">??</span></code></dt>
<dd class="field-even"><p>Object was not synchronized, and so unknown to DataONE</p>
</dd>
<dt class="field-odd"><span class="math notranslate nohighlight">\(resolve(S_i) \Rrightarrow P_j\)</span></dt>
<dd class="field-odd"><p>Resolving SID <span class="math notranslate nohighlight">\(S_i\)</span> results in PID <span class="math notranslate nohighlight">\(P_j\)</span></p>
</dd>
</dl>
<div class="section" id="case-1">
<h3><a class="toc-backref" href="#id5">Case 1</a><a class="headerlink" href="#case-1" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c1">
<span class="eqno">(1)<a class="headerlink" href="#equation-c1" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} &amp; \leftrightarrows P_2\binom{S_1}{t_2} \\
t_1 &amp; &lt; t_2 \\
resolve(S_1) &amp; \Rrightarrow P_2\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>All objects in <span class="math notranslate nohighlight">\(O\)</span> are participants in an obsolescence chain since <span class="math notranslate nohighlight">\(P_2\)</span>
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a> <span class="math notranslate nohighlight">\(P_1\)</span> and <span class="math notranslate nohighlight">\(P_1\)</span> is
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a> <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>All elements of the obsolescence chain <span class="math notranslate nohighlight">\(P_1 \leftrightarrows P_2\)</span> have the
same series identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>The <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> of <span class="math notranslate nohighlight">\(P_1\)</span> is older than that of
<span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>This is a perfect obsolescence chain and resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in the
object identified by <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
</div>
<div class="section" id="case-2">
<h3><a class="toc-backref" href="#id6">Case 2</a><a class="headerlink" href="#case-2" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c2">
<span class="eqno">(2)<a class="headerlink" href="#equation-c2" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1}\; &amp; \square \; P_2\binom{S_1}{t_2} \\
t_1 &amp; &lt; t_2 \\
resolve(S_1) &amp; \Rrightarrow P_2\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>No obsolescence information associates objects in <span class="math notranslate nohighlight">\(O\)</span>.</p>
<p>The <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> of <span class="math notranslate nohighlight">\(P_1\)</span> is older than that of
<span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>No obsolescence assertions are made, so resolution is inferred by the most
recent value of <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a>.</p>
</div>
<div class="section" id="case-3">
<h3><a class="toc-backref" href="#id7">Case 3</a><a class="headerlink" href="#case-3" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c3">
<span class="eqno">(3)<a class="headerlink" href="#equation-c3" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1}\; &amp; \leftarrow \; P_2\binom{S_1}{t_2} \\
t_1 &amp; &lt; t_2 \\
resolve(S_1) &amp; \Rrightarrow P_2\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>All objects in <span class="math notranslate nohighlight">\(O\)</span> are participants in an obsolescence chain since <span class="math notranslate nohighlight">\(P_2\)</span>
<a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletes" title="Types.SystemMetadata.obsoletes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletes</span></code></a> <span class="math notranslate nohighlight">\(P_1\)</span> even though <span class="math notranslate nohighlight">\(P_1\)</span> does not assert
it is <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.obsoletedBy" title="Types.SystemMetadata.obsoletedBy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obsoletedBy</span></code></a> <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>All elements of the obsolescence chain <span class="math notranslate nohighlight">\(P_1 \leftarrow P_2\)</span> have the
same series identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>The <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> of <span class="math notranslate nohighlight">\(P_1\)</span> is older than that of
<span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>This is a damaged, but consistent obsolescence chain and resolving <span class="math notranslate nohighlight">\(S_1\)</span> will
result in the object identified by <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
</div>
<div class="section" id="case-4">
<h3><a class="toc-backref" href="#id8">Case 4</a><a class="headerlink" href="#case-4" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c4">
<span class="eqno">(4)<a class="headerlink" href="#equation-c4" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \leftrightarrows
P_3\binom{S_2}{t_3}\\
t_1 &lt; t_2 &amp; &lt; t_3 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\
resolve(S_2) &amp;\Rrightarrow P_3 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_3 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup O_{S_2}\)</span> all participate in a full,
bi-directional obsolescence chain.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_2\)</span> will result in <span class="math notranslate nohighlight">\(P_3\)</span>.</p>
</div>
<div class="section" id="case-5">
<h3><a class="toc-backref" href="#id9">Case 5</a><a class="headerlink" href="#case-5" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c5">
<span class="eqno">(5)<a class="headerlink" href="#equation-c5" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftarrow
P_2\binom{S_1}{t_2}&amp; \leftarrow
P_3\binom{S_2}{t_3}\\
t_1 &lt; t_2 &amp; &lt; t_3 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\
resolve(S_2) &amp;\Rrightarrow P_3 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_3 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup O_{S_2}\)</span> all participate in a damaged, though
consistent obsolescence chain.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_2\)</span> will result in <span class="math notranslate nohighlight">\(P_3\)</span>.</p>
</div>
<div class="section" id="case-6">
<h3><a class="toc-backref" href="#id10">Case 6</a><a class="headerlink" href="#case-6" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c6">
<span class="eqno">(6)<a class="headerlink" href="#equation-c6" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \leftrightarrows
P_3\binom{}{t_3}\\
t_1 &lt; t_2 &amp; &lt; t_3 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup P_3\)</span> all participate in an obsolescence chain.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
</div>
<div class="section" id="case-7">
<h3><a class="toc-backref" href="#id11">Case 7</a><a class="headerlink" href="#case-7" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c7">
<span class="eqno">(7)<a class="headerlink" href="#equation-c7" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \leftrightarrows
P_3\binom{}{t_3} \leftrightarrows
P_4\binom{S_2}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_3 &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_2 \\
resolve(S_2) &amp;\Rrightarrow P_4\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_4 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup P_3 \cup O_{S_2}\)</span> all participate in an
obsolescence chain.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_2\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span></p>
</div>
<div class="section" id="case-8">
<h3><a class="toc-backref" href="#id12">Case 8</a><a class="headerlink" href="#case-8" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c8">
<span class="eqno">(8)<a class="headerlink" href="#equation-c8" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \rightarrow
?? \leftarrow
P_4\binom{S_1}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_4 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_4 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> all participate in an obsolescence chain, however the
chain is broken with no way to traverse between <span class="math notranslate nohighlight">\(P_2\)</span> and <span class="math notranslate nohighlight">\(P_4\)</span> because the
object that <span class="math notranslate nohighlight">\(P_2\)</span> indicates it is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code>, and the object that <span class="math notranslate nohighlight">\(P_4\)</span>
indicates it <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> is not recorded by the DataONE Coordinating Nodes
(does not resolve).</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span> since that is the most recent
object in the set of objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span>.</p>
</div>
<div class="section" id="case-9">
<h3><a class="toc-backref" href="#id13">Case 9</a><a class="headerlink" href="#case-9" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c9">
<span class="eqno">(9)<a class="headerlink" href="#equation-c9" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \;\square\;
?? \leftarrow
P_4\binom{S_1}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_4 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_4 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> all participate in an obsolescence chain, however the
chain is broken with no way to traverse between <span class="math notranslate nohighlight">\(P_2\)</span> and <span class="math notranslate nohighlight">\(P_4\)</span> because the the
object that <span class="math notranslate nohighlight">\(P_4\)</span> indicates it <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> is not recorded by the DataONE
Coordinating Nodes (does not resolve).</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span> since that is the most recent
object in the set of objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span>.</p>
</div>
<div class="section" id="case-10">
<h3><a class="toc-backref" href="#id14">Case 10</a><a class="headerlink" href="#case-10" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c10">
<span class="eqno">(10)<a class="headerlink" href="#equation-c10" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \rightarrow
P_{del}\binom{}{} \leftarrow
P_4\binom{S_1}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_4 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_4 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>The object <span class="math notranslate nohighlight">\(P_{del}\)</span> was deleted from the system, so the identifier is
known, but the object and associated system metadata are no longer available.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> all participate in an obsolescence chain, however the
chain is broken with no way to traverse between <span class="math notranslate nohighlight">\(P_2\)</span> and <span class="math notranslate nohighlight">\(P_4\)</span> because the
object that <span class="math notranslate nohighlight">\(P_2\)</span> indicates it is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code>, and the object that <span class="math notranslate nohighlight">\(P_4\)</span>
indicates it <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> is not recorded by the DataONE Coordinating Nodes
(does not resolve).</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span> since that is the most recent
object in the set of objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span>.</p>
</div>
<div class="section" id="case-11">
<h3><a class="toc-backref" href="#id15">Case 11</a><a class="headerlink" href="#case-11" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c11">
<span class="eqno">(11)<a class="headerlink" href="#equation-c11" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2}&amp; \leftrightarrows
archived\biggl[P_3\binom{S_1}{t_3}\biggr] \\
t_1 &lt; t_2 &amp; &lt; t_3 \\
resolve(S_1) &amp;\Rrightarrow P_3 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_3 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> all participate in an obsolescence chain.</p>
<p>Object <span class="math notranslate nohighlight">\(P_3\)</span> has been archived, and so is not discoverable.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_3\)</span> which is the most recent
object in the obsolescence chain even though it is archived.</p>
</div>
<div class="section" id="case-12">
<h3><a class="toc-backref" href="#id16">Case 12</a><a class="headerlink" href="#case-12" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c12">
<span class="eqno">(12)<a class="headerlink" href="#equation-c12" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} &amp; \leftrightarrows
P_2\binom{S_1}{t_2} \rightarrow
?? \\
t_1 &amp; &lt; t_2 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> participate in an obsolescence chain which is damaged
by <span class="math notranslate nohighlight">\(P_2\)</span> indicating it is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> some object that is not resolvable.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is the most recent
resolvable object in the obsolescence chain.</p>
</div>
<div class="section" id="case-13">
<h3><a class="toc-backref" href="#id17">Case 13</a><a class="headerlink" href="#case-13" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c13">
<span class="eqno">(13)<a class="headerlink" href="#equation-c13" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} &amp; \leftarrow
P_2\binom{S_1}{t_2} \rightarrow
?? \\
t_1 &amp; &lt; t_2 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> participate in a damaged obsolescence chain since <span class="math notranslate nohighlight">\(P_2\)</span>
indicates it is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> some object that is not resolvable, and <span class="math notranslate nohighlight">\(P_1\)</span>
does not assert it is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is the most recent
resolvable object in the obsolescence chain.</p>
</div>
<div class="section" id="case-14">
<h3><a class="toc-backref" href="#id18">Case 14</a><a class="headerlink" href="#case-14" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c14">
<span class="eqno">(14)<a class="headerlink" href="#equation-c14" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftarrow
P_2\binom{S_1}{t_2}&amp; \rightarrow
P_3\binom{S_2}{t_3}\\
t_1 &lt; t_2 &amp; &lt; t_3 \\
resolve(S_1) &amp;\Rrightarrow P_2 \\
resolve(S_2) &amp;\Rrightarrow P_3\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_3 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup O_{S_2}\)</span> all participate in a damaged
obsolescence chain, with <span class="math notranslate nohighlight">\(P_1\)</span> not indicating it is obsoleted by <span class="math notranslate nohighlight">\(P_2\)</span>, and <span class="math notranslate nohighlight">\(P_3\)</span>
not indicating that it obsoletes <span class="math notranslate nohighlight">\(P_2\)</span>.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p><span class="math notranslate nohighlight">\(S_2\)</span> will resolve to <span class="math notranslate nohighlight">\(P_3\)</span>.</p>
</div>
<div class="section" id="case-15">
<h3><a class="toc-backref" href="#id19">Case 15</a><a class="headerlink" href="#case-15" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c15">
<span class="eqno">(15)<a class="headerlink" href="#equation-c15" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2} \; &amp; \square \;
?? \leftarrow
P_4\binom{S_1}{t_4} \leftrightarrows
P_5\binom{S_2}{t_5}\\
t_1 &lt; t_2 &amp; &lt; t_4 &lt; t_5\\
resolve(S_1) &amp;\Rrightarrow P_4 \\
resolve(S_2) &amp;\Rrightarrow P_5\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_4 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_5 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O = O_{S_1} \cup P_3 \cup O_{S_2}\)</span> all participate in a damaged
obsolescence chain with no assertion of the relationship between <span class="math notranslate nohighlight">\(P_2\)</span> and <span class="math notranslate nohighlight">\(P_4\)</span>.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span> which is not the most recent
object in the obsolescence chain, however it is the newest version in the
obsolescence chain identified by <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_2\)</span> will result in <span class="math notranslate nohighlight">\(P_5\)</span>.</p>
</div>
<div class="section" id="case-16">
<h3><a class="toc-backref" href="#id20">Case 16</a><a class="headerlink" href="#case-16" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c16">
<span class="eqno">(16)<a class="headerlink" href="#equation-c16" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftarrow
P_2\binom{S_1}{t_2} &amp; \rightarrow
?? \leftarrow
P_4\binom{S_2}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_2 \\
resolve(S_2) &amp;\Rrightarrow P_4\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2 \rbrace\)</span> have the same series
identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_2} = \lbrace P_4 \rbrace\)</span> has the series
identifier, <span class="math notranslate nohighlight">\(S_2\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> and <span class="math notranslate nohighlight">\(O_{S_2}\)</span> are both damaged obsolescence
chains though the Coordinating Nodes may infer association between
<span class="math notranslate nohighlight">\(O_{S_1}\)</span> and <span class="math notranslate nohighlight">\(O_{S_2}\)</span> since even though the object that <span class="math notranslate nohighlight">\(P_2\)</span> is
<code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> and the object that <span class="math notranslate nohighlight">\(P_4\)</span> <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> can not be resolved,
<span class="math notranslate nohighlight">\(P_2.obsoletedBy\)</span> and <span class="math notranslate nohighlight">\(P_4.obsoletes\)</span> are be the same value.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_2\)</span> which is the most recent
resolvable object in the obsolescence chain.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_2\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span>.</p>
</div>
<div class="section" id="case-17">
<h3><a class="toc-backref" href="#id21">Case 17</a><a class="headerlink" href="#case-17" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c17">
<span class="eqno">(17)<a class="headerlink" href="#equation-c17" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftarrow
P_2\binom{S_1}{t_2} &amp; \rightarrow
?? \leftarrow
P_4\binom{S_1}{t_4} \\
t_1 &lt; t_2 &amp; &lt; t_4\\
resolve(S_1) &amp;\Rrightarrow P_4\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_4 \rbrace\)</span> have the same
series identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> form a damaged obsolescence chain though it can be
inferred that <span class="math notranslate nohighlight">\(P_2\)</span> is <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> and <span class="math notranslate nohighlight">\(P_4\)</span> <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> the same object
even though it can not be resolved, <span class="math notranslate nohighlight">\(P_2.obsoletedBy\)</span> and
<span class="math notranslate nohighlight">\(P_4.obsoletes\)</span> are be the same value.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_4\)</span>.</p>
</div>
<div class="section" id="case-18">
<h3><a class="toc-backref" href="#id22">Case 18</a><a class="headerlink" href="#case-18" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c16">
<span class="eqno">(18)<a class="headerlink" href="#equation-c16" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftrightarrows
P_2\binom{S_1}{t_2} &amp; \rightarrow
?? \; \square \; ?? \leftarrow
P_5\binom{S_1}{t_5} \\
t_1 &lt; t_2 &amp; &lt; t_5\\
resolve(S_1) &amp;\Rrightarrow P_5\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_5 \rbrace\)</span> have the same
series identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>The obsolescence chain <span class="math notranslate nohighlight">\(O_{S_1}\)</span> is broken, with no way to traverse from
<span class="math notranslate nohighlight">\(P_2\)</span> to <span class="math notranslate nohighlight">\(P_5\)</span>.</p>
<p>The <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> places <span class="math notranslate nohighlight">\(P_5\)</span> as the newest
object with the series Id of <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Resolving <span class="math notranslate nohighlight">\(S_1\)</span> results in <span class="math notranslate nohighlight">\(P_5\)</span>.</p>
</div>
<div class="section" id="case-19">
<h3><a class="toc-backref" href="#id23">Case 19</a><a class="headerlink" href="#case-19" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight" id="equation-c17">
<span class="eqno">(19)<a class="headerlink" href="#equation-c17" title="Permalink to this equation">¶</a></span>\[\begin{split}P_1\binom{S_1}{t_1} \leftarrow
P_2\binom{S_1}{t_2} &amp; \leftarrow
P_3\binom{S_1}{t_3} \\
t_1 &gt; t_2 &amp; &gt; t_3\\
resolve(S_1) &amp;\Rrightarrow P_3\end{split}\]</div>
<p>A set of objects <span class="math notranslate nohighlight">\(O_{S_1} = \lbrace P_1, P_2, P_3 \rbrace\)</span> have the same
series identifier, <span class="math notranslate nohighlight">\(S_1\)</span>.</p>
<p>Objects <span class="math notranslate nohighlight">\(O_{S_1}\)</span> form a damaged obsolescence chain since only
<code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> values are specified.</p>
<p>The <a class="reference internal" href="../apis/Types.html#Types.SystemMetadata.dateUploaded" title="Types.SystemMetadata.dateUploaded"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dateUploaded</span></code></a> of <span class="math notranslate nohighlight">\(P_1\)</span> is newer than <span class="math notranslate nohighlight">\(P_2\)</span>,
which in turn is newer than <span class="math notranslate nohighlight">\(P_3\)</span>.</p>
<p>In this case resolving <span class="math notranslate nohighlight">\(S_1\)</span> will result in <span class="math notranslate nohighlight">\(P_3\)</span> even though <span class="math notranslate nohighlight">\(P_1\)</span> is the most
recent object since the obsolescence chain overrides the times.</p>
</div>
</div>
<div class="section" id="referencing-content-by-identifier">
<h2><a class="toc-backref" href="#id24">Referencing Content by Identifier</a><a class="headerlink" href="#referencing-content-by-identifier" title="Permalink to this headline">¶</a></h2>
<p>The use of the PID or SID for either citation or analysis workflows is up to the
user and is context dependent. In general, DataONE anticipates <code class="docutils literal notranslate"><span class="pre">DATA</span></code> and
<code class="docutils literal notranslate"><span class="pre">RESOURCE_MAP</span></code>  objects will be referenced by PID, to ensure reproducibility;
and in general,  <code class="docutils literal notranslate"><span class="pre">METADATA</span></code> documents will be referenced by SID, to take
advantage of any data  curation / correction efforts that would not otherwise
affect scientific  reproducibility.  Additionally, clues for the content
submitter’s preference can  be found in the format of the identifiers
themselves. For example, DOIs and EZIDs  take a recognizable format, and are
often encouraged in scientific communities for  citations, so an end-user might
take that into consideration when deciding which  identifier to choose.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>guidance on RESOURCE_MAPS - initial thoughts: depends on references to DATA
objects, whether they be SIDs or PIDs</p>
</div>
</div>
<div class="section" id="assigning-identifiers">
<h2><a class="toc-backref" href="#id25">Assigning Identifiers</a><a class="headerlink" href="#assigning-identifiers" title="Permalink to this headline">¶</a></h2>
<p>Depending on the Member Node used as the primary repository, content originators
may have some choice in assigning identifiers. For those that do, it is advised
that they assign PIDs and SIDs according to the typical usage pattern described
above.</p>
<p>Some Member Nodes may not preserve past versions of content, in which case the
PID is likely to be automatically generated, and the submitter only has to
determine the SID, and may not need to know the difference between the SID and
PID.  Other Member Nodes may still be at v1 of the DataONE APIs and only allow
assignment of the PID.</p>
</div>
<div class="section" id="limits-on-the-series">
<h2><a class="toc-backref" href="#id26">Limits on the Series</a><a class="headerlink" href="#limits-on-the-series" title="Permalink to this headline">¶</a></h2>
<p>The SID is used to conceptually represent an object that may vary modestly over
time, but remains conceptually the same. Content contributers should be careful
to apply reasonable limits on the scope of documents such that an entity does
not deviate too much from the original item.  In such cases, a new / different
series should be initiated.</p>
</div>
<div class="section" id="requirements-on-member-node-implementations">
<h2><a class="toc-backref" href="#id27">Requirements on Member Node Implementations</a><a class="headerlink" href="#requirements-on-member-node-implementations" title="Permalink to this headline">¶</a></h2>
<p>For Member Nodes that employ a mutable content storage model, the only
additional DataONE requirement is that the Member Node generate a SystemMetadata
document for the updated content, containing:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>unique PID in systemMetadata.identifier field</p></li>
<li><p>new checksum</p></li>
<li><p>the previous PID in the systemMetadata.obsoletes field</p></li>
</ol>
</div></blockquote>
<p>Ideally, the SystemMetadata of now unavailable versions will be maintained, and
the <code class="docutils literal notranslate"><span class="pre">obsoletedBy</span></code> field is populated with the PID of the version that replaced
it.</p>
<p>Some Member Nodes may opt to preserve recent back-versions to aid the complete
capture of versions by the DataONE network via synchronization.</p>
</div>
<div class="section" id="reassignment-of-authoritativemembernode-field-for-unhosted-versions">
<h2><a class="toc-backref" href="#id28">Reassignment of AuthoritativeMemberNode field for unhosted versions</a><a class="headerlink" href="#reassignment-of-authoritativemembernode-field-for-unhosted-versions" title="Permalink to this headline">¶</a></h2>
<p>to be determined</p>
</div>
<div class="section" id="replication-of-unhosted-back-versions">
<h2><a class="toc-backref" href="#id29">Replication of unhosted back-versions</a><a class="headerlink" href="#replication-of-unhosted-back-versions" title="Permalink to this headline">¶</a></h2>
<p>DataONE will attempt to synchronize all versions it’s made aware of through the
synchronization process, but may miss short-lived versions that are in existence
only between the Member Node’s synchronization interval.    Please note, also,
that the synchronization schedule is not guaranteed.  Periods of DataONE
maintenance may suspend synchronization, or high CN load could prolong the
synchronization interval.</p>
<p>Member Nodes keen to make sure versions have the highest chance of
synchronization can choose to issue a <code class="xref py py-func docutils literal notranslate"><span class="pre">CNCore.synchronize()</span></code> command that
will put the item on the synchronization queue instead of waiting for the
harvest interval.</p>
<p>Conversely, if the Member Node expressly doesn’t want DataONE to preserve
back-versions, they can set systemMetadata.replicationPolicy.numberReplicas
field to 0.</p>
</div>
<div class="section" id="synchronizing-content-from-mutable-member-nodes">
<h2><a class="toc-backref" href="#id30">Synchronizing Content from Mutable Member Nodes</a><a class="headerlink" href="#synchronizing-content-from-mutable-member-nodes" title="Permalink to this headline">¶</a></h2>
<p>At its core, DataONE is in the business of preserving definite versions of
content through centrally coordinated per-to-peer replication.  That is, DataONE
Coordinating Nodes direct certain Member Nodes to replicate newly synchronized
objects from the originating Member Node to better preserve it.  New versions of
objects appear as first class immutable objects with unique PIDs, even if
originating from mutable Member Nodes.</p>
<p>From the DataONE perspective the only difference between objects from mutable
Member Nodes and immutable Member Nodes is the completeness of the series of
versions it is able to synchronize and replicate.</p>
</div>
<div class="section" id="the-problem">
<h2><a class="toc-backref" href="#id31">The Problem</a><a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h2>
<p>Current DataONE replication processes and fixity checks depend on content
identified by a PID that does not change. If this were not enforced, mutable
content from a member node would not be differentiated from corrupt copies of
the object and our replication and recovery features would attempt to correct
the byte inconsistency. The immutability requirement helps to ensure
reproducible results of any use of an object. Any analysis on a data set
repeated sometime in the future should yield identical results (within the
limits of precision of the analytical tools) and this is one of the major
guiding principles in creating DataONE as a long term data repository
federation. By simply overwriting existing content using the same identifier,
nodes cannot be relied upon for repeatable retrieval of content.</p>
</div>
<div class="section" id="proposal">
<h2><a class="toc-backref" href="#id32">Proposal</a><a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>The proposal for supporting “mutable” content is to allow a series identifier
(SID) to facilitate the semantics of citing an object at the conceptual level,
instead of the version level. As content changes over time, new identifiers
(PIDs) will still be used to mark each change, but the conceptual object can
continue to be referred to with an unchanging identifier (SID). The member node
will be responsible for creating each version and assigning a unique PID to it
and these objects will be synchronized and replicated to other DataONE member
nodes as they are today. So instead of allowing content to be directly modified,
we are allowing strongly-versioned chains to be referenced by an identifier; and
relaxing the requirement that all revisions be resolvable forever.</p>
</div>
<div class="section" id="the-series-identifier">
<h2><a class="toc-backref" href="#id33">The Series Identifier</a><a class="headerlink" href="#the-series-identifier" title="Permalink to this headline">¶</a></h2>
<p>The proposed solution is to model and implement a “series identifier” (SID)
along with modified services that would work with both SIDs and PIDs.  From a
DataONE perspective, the series identifiers would be assigned to all versions of
an object, be unique in DataONE (assigned to only one version chain), and would
be reserved just as PIDs - from the same namespace.  The series identifier, once
assigned to the version chain, would similarly be immutable, and could apply to
all new versions of the item.   It is also assumed that in order to coordinate
users to use one identifier for citations, that the cardinality for the citation
identifier would be 0..1.  The semantics for making API calls with a SID would,
in general, be to return responses as if the call were made with the most
current PID.</p>
<p>Member Nodes that only maintain the latest version of an item would be required
to use a new PID for any updated content, and modify the System Metadata
appropriately so that the new version can be synchronized with the network. The
same SID would typically be used for the updated object, although we would allow
the revision chain to shift to a new SID as desired by the client and/or member
node.</p>
<p>It cannot be assumed that a user with an identifier in hand knows whether it is
a SID or a PID, so DataONE expects the user to refer to the System Metadata once
it has the item to determine if the identifier used in the call matches the PID
or the SID.  Similarly, they could interrogate search results for the same
information.  For high-level interfaces, like D1Client.getD1Object(id), the PID
of the object returned may or may not match the passed in ‘id’.  So, high-level
functions or applications that use resolve will have to make sure they handle
the new resolving semantics.</p>
<p>It is recommended that search indexes include a search field for the
series identifier that can also be returned in the results.</p>
<div class="section" id="semantics-of-current">
<h3><a class="toc-backref" href="#id34">Semantics of “Current”</a><a class="headerlink" href="#semantics-of-current" title="Permalink to this headline">¶</a></h3>
<p>A SID chain closes with two types of ends:</p>
<p>Type 1: An object on the SID chain doesn’t have the “obsoletedBy” field.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>P1(S1) ⟺ P2(S1)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">P2</span></code> is a type 1 end.</p>
<p>Type 2: An object on the SID chain does have the “obsoletedBy” field, but the
PID in the “obsoletedBy” field has a different SID (including no SID value).</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>P1(S1) ⟺ P2(S2)

P1(S1) ⟺ P2()
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">P1</span></code> is a type 2 end on both chains.</p>
<p>It is tricky to determine a type 2 end if the object in the “obsoletedBy” field
is missing. For example, <code class="docutils literal notranslate"><span class="pre">P1(S1)</span> <span class="pre">⟺</span> <span class="pre">P2(S1)</span> <span class="pre">⟹</span> <span class="pre">??</span></code>. We don’t have the
knowledge of the series id of the object “??”. So we generally consider it a
type 2 end except we are sure it is not an end - there is another object in the
chain (has the same series id) that obsoletes the missing object.</p>
<p>In previous example [P1(S1) ⟺ P2(S1) ⟹ ??], P2 is a type 2 end (case 12).</p>
<p>However,  P1(S1) ⟺ P2(S1) ⟹  ??  ⟸ P4(S1), P2 is not an end (case 8) since “??” is in the obsoletes field of P4 that has the same series id - S1 (We are sure that the “??” has the series id S1 as well, so P2 is not an end).</p>
<p>In P1(S1) ⟺ P2(S1) ⟹  ??  ⟸ P4(S2), P2 is a type 2 end even though “??” is in the  obsoletes field of P4. But P4 has a different series id - S2 (so we are not sure “??” has the S1 or S2).</p>
<p>Ideally, if there is one and only one end on a SID chain, this end will be the HEAD (current) version. This kind of chains are called ideal chains.</p>
<dl class="simple">
<dt>If there are more than one end on a SID chain because of the incompleteness of the system metadata, It is hard to determine which one is the real end. This kind of chain is not a ideal chain and we have to use this mechanism to determine the HEAD version:</dt><dd><ol class="arabic simple">
<li><p>Choose the end with latest dateUploaded in the chain as the temporary HEAD version. This rule works if the uploaded time stamps of objects aren’t messed up.</p></li>
<li><p>If the time stamps are messed up, we need to test if any object obsoletes the temporary HEAD on the obsolete chain with the SAME SID. If nothing obsoletes the temporary HEAD, the temporary HEAD is the final HEAD; otherwise, the end of obsolete chain is the final HEAD.</p></li>
</ol>
</dd>
<dt>Take this example P1[S1, t1] ⟸P2[S1, t2] ⟸P3(S1, t3) (case 19) (The t1, t2 and t3 are time stamps and t1 &gt; t2 &gt; t3. This means the time stamps are messing up - the newest version P3 was uploaded the earliest while the oldest version p1 was uploaded the latest)</dt><dd><ol class="arabic simple">
<li><p>This chain has three type 1 ends - P1, P2 and P3. It is not an ideal chain.</p></li>
<li><p>Choose P1 which has the latest date of uploaded as the temporary HEAD.</p></li>
<li><p>P2 obsoletes P1 and also P3 obsoletes P2 on the obsolete chain P1 ⟸ P2 ⟸ P3. So we choose the end of the whole chain - P3 as the final HEAD.</p></li>
</ol>
</dd>
</dl>
<div class="section" id="version-storage">
<h4><a class="toc-backref" href="#id35">Version Storage</a><a class="headerlink" href="#version-storage" title="Permalink to this headline">¶</a></h4>
<p>Mutable content implies that back-versions of content may not be readily available
on the nodes that originally produce the content. For metadata and resource maps,
the coordinating nodes will store previous versions of objects during the synchronization process,
but any data updates will result in only the latest version being available at the originating node.
If the data objects were replicated (as is the hope), it is likely that previous versions of
the data can still be resolved from replica target nodes, though this is dependent on replication policies,
synchronization schedules and the availability of replica storage across the federation.</p>
<p>The current DataONE storage model, through the MN_Storage.update method, places
responsibility for storing versions squarely on the submitter. Each update to the object requires
a new unique identifier (PID) and must state which PID the new version is obsoleting.
We will continue to require that unique PIDs are provided for each
and every version of an object, but the member node will not be required to maintain a copy of previous revisions
if it chooses not to. An optional series identifier (SID) can be provided with object SystemMetadata
to group revisions together and to provide a convenient way to refer to the latest version of the object.</p>
</div>
</div>
<div class="section" id="version-preservation">
<h3><a class="toc-backref" href="#id36">Version preservation</a><a class="headerlink" href="#version-preservation" title="Permalink to this headline">¶</a></h3>
<p>As is currently the case, the member node should maintain all versions of content using
unique identifiers (PID) and synchronization will harvest each new revision to the network.
While there will be no requirement that the Member node continue to make available the object identified
by the obsoleted PID, the hope is that they will persist the data history as best they can.
If the objects in the revision chain have a SID assigned, the new PID will be considered the latest
version of this series.</p>
<p>The member node can allow access to the current version of the object using MN_Read.get(sid) as a convenience and
any reference to the SID would resolve to the latest version of the object with a potentially different checksum and PID
from what was originally present when the citation was distributed.</p>
<p>The member node must [minimally] maintain system metadata for the current revision of the object.
Any updated object is still required to be identified by a new unique PID, but would include the same SID used
in the previous version. The obsoletes field should indicate that the new PID replaces the previous PID.
The coordinating node learns about the updated content during synchronization because there is:</p>
<blockquote>
<div><ul class="simple">
<li><p>a new PID</p></li>
<li><p>an updated dateSystemMetadataUpdated timestamp</p></li>
<li><p>an updated checksum (other fields may also be updated).</p></li>
</ul>
</div></blockquote>
<p>N.B. Multiple revisions between synchronization periods would not
result in multiple versions recorded in the federation - just the revision[s] that happened to be
synchronized would be persisted in DataONE. This leaves open the possibility of an end user retrieving a version from the MN that
will ultimately not be persisted in perpetuity.</p>
</div>
<div class="section" id="working-drafts-vs-repository-publishing">
<h3><a class="toc-backref" href="#id37">Working drafts vs. Repository publishing</a><a class="headerlink" href="#working-drafts-vs-repository-publishing" title="Permalink to this headline">¶</a></h3>
<p>DataONE essentially considers member nodes as the originators of <em>selected</em> versions of
content.  That is, not every intermediate revision on the way to a final
product should neccessarily be saved for future reference.  Organizations following the mutable
content model for storage may wish to limit the objects returned by listObjects() to those that
are considered in their publishable form. Certainly theses objects can later be updated as needed,
but minimizing draft-status objects will reduce the amount of [possibly irretrievable] draft content floating around
the federated network.</p>
<div class="section" id="types-of-mutable-objects">
<h4><a class="toc-backref" href="#id38">Types of Mutable Objects</a><a class="headerlink" href="#types-of-mutable-objects" title="Permalink to this headline">¶</a></h4>
<p>As illustrated in the optional use cases, the rate and regularity of change of
objects can be widely variable. The more frequent the change, the less likely
that all versions would need to be reproduced, and the utility of complete version
history diminishes.  One can imagine a member node serving up an unrecorded data
stream, such as a web-cam, delaying creating a version until a user calls MN.get()
on the item, by tee’ing the output stream to file while returning the object.</p>
<p>Additionally the need to keep past versions may be less important for metadata
objects (correcting typos that do not change the meaning or interpretation of the data)
than data objects or resource maps.</p>
</div>
</div>
<div class="section" id="accumulating-datasets">
<h3><a class="toc-backref" href="#id39">Accumulating datasets</a><a class="headerlink" href="#accumulating-datasets" title="Permalink to this headline">¶</a></h3>
<p>The use case of mutable data objects that grow with new records appended to the
end of a table, for example, was given as a common practice for some groups, and
one that would produce progressively redundant information with each persisted
version.  The motivation for rolling up records accumulated over time instead
of new data files for each is the ease of use for end users. Using a SID to access
the data object will always give the latest snapshot of the data records where old revisions
may or may not also be accessible.</p>
</div>
<div class="section" id="mixed-metadata-data-objects">
<h3><a class="toc-backref" href="#id40">Mixed metadata-data objects</a><a class="headerlink" href="#mixed-metadata-data-objects" title="Permalink to this headline">¶</a></h3>
<p>Objects like NetCDF files that include both metadata and data in the same object
will be managed with the same PID and SID considerations. If only the metadata portion of
the file is modified, the SID may remain the same, but a new PID and checksum must be created and
made available for synchronization. The old revision may immediately become inaccessible using the PID
and that is allowable under the proposal.</p>
<div class="section" id="retrieval-citation-support">
<h4><a class="toc-backref" href="#id41">Retrieval / Citation Support</a><a class="headerlink" href="#retrieval-citation-support" title="Permalink to this headline">¶</a></h4>
<p>Implicit in the support for versioned content is support for retrieval of, or possibly
just resolution to, the current object bytes by the identifier assigned in the
originating system.  At a minimum CNs will be required to support calculating
which is the current version of series of versions and returning it or its
identifier. This will be accomplished using the series identifier (SID) associated with object[s]
in a revision chain. The “current” version of an object is defined as the non-obsoleted object with
a SID that matches the requested identifier. Objects that are marked as “archived” may be returned as the
most current version, but they should not be seen in default search interfaces.
Since DataONE identifiers have no special formating semantics, those following a citation
will not know by looking at the identifier whether it is referring to a specific
version (PID) or the latest version of the item (SID), so services may be provided to easily investigate
an entire version series. Existing services allow clients to deduce this information by inspecting the system
metadata for the identifier and following any obsolescence properties as needed.</p>
</div>
</div>
<div class="section" id="retrieval-vs-resolution">
<h3><a class="toc-backref" href="#id42">Retrieval vs. Resolution</a><a class="headerlink" href="#retrieval-vs-resolution" title="Permalink to this headline">¶</a></h3>
<p>Because the content of an object is retrieved in a separate call from its system
metadata, use of the SID for MN Read API calls is troublesome because the content may be updated
between the two calls.
It would be impossible to tell if the bytes retrieved were incorrect (bit rot) or correct (newer version)
when comparing checksums in this case. If data consistency is important to the caller, the PID should be used
to guarantee that only the expected bytes (or a NotFound exception) are returned by any MN.get calls.</p>
<p>Those making a citation may wish to cite a specific version, or the latest current
version.  Followers of citations may wish to, if given an identifier representing
a specific version (PID), find out what is the latest version (another, newer PID, or the SID).
Conversely, if given a series identifier that navigates to the latest version, they may wish to find
out what the content was at some previous point in time (e.g., the time of the citation) by following
the obsolescence chain backward.</p>
</div>
<div class="section" id="service-development-plans">
<h3><a class="toc-backref" href="#id43">Service development plans</a><a class="headerlink" href="#service-development-plans" title="Permalink to this headline">¶</a></h3>
<p>DataONE will be providing CN services for navigating to the latest version of an object, since the only way
to do it currently is for the clients to serially retrieve the system metadata for
versions in the chain until they reach the head version, which is can be inefficient.
A new method to retrieve the entire version history is also under consideration.</p>
</div>
<div class="section" id="mn-api-method-changes">
<h3><a class="toc-backref" href="#id44">MN API method changes</a><a class="headerlink" href="#mn-api-method-changes" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>MN.get(Identifier id):</dt><dd><p>Identifier can be either a PID or SID, and if a SID, return the bytes of the HEAD PID in the series.</p>
</dd>
<dt>MN.getSystemMetadata(Identifier id):</dt><dd><p>If PID, return SystemMetadata of PID.
If SID, return HEAD PID SystemMetadata.</p>
</dd>
<dt>MN.describe(Identifier id):</dt><dd><p>If PID, return header for PID.
If SID, return header for HEAD PID.</p>
</dd>
<dt>MN.getChecksum(Identifier pid):</dt><dd><p>Requires PID to effectively verify data integrity.</p>
</dd>
<dt>MN.create(Identifier pid, object, SystemMetadata):</dt><dd><p>Identifier must be PID and included in accompanying systemMetadata.
SID may be included in accompanying systemMetadata if known at time of creation. The SID mustn’t exist in the system.</p>
</dd>
<dt>MN.update(Identifier id, Identifier newPid, SystemMetadata):</dt><dd><p>Identifier id may be a PID or SID – in the case of a SID, the method works with the HEAD PID of the chain.
The new Identifier must be a PID and must match the accompanying SystemMetadata.
The new SID can match the old SID in previous SystemMetadata (objects are in the same series),
or it can be any unique SID that does not already exist in the system (newly assigning a SID or shifting the SID because of a “scientifically meaningful change”).
Moreover, the new system metadata may not have a SID no matter the previous version has a SID or not.</p>
</dd>
<dt>MN.getLogRecords(?idFilter):</dt><dd><p>Filter can be PID or SID. The MN should resolve the SID to the HEAD PID, and return the log records for that PID.
If a client wishes to retrieve log records for the entire family of objects referenced by a SID, then the client should retrieve a list of PIDs for the SID, the call getLogRecords for each PID to retrieve the entire set of log records.
The Log.identifier field will only contain PID values, no SIDs.</p>
</dd>
<dt>MN.delete(Identifier id):</dt><dd><p>Identifier can be PID or SID.
If PID, delete that specific version;
If a SID, delete the HEAD PID version.</p>
</dd>
<dt>MN.archive(Identifier id):</dt><dd><p>Identifier can be PID or SID.
If PID, archive that specific version.
If a SID, archive the HEAD PID.</p>
</dd>
<dt>MN.isAuthorized(Identifier id):</dt><dd><p>Can accept either PID or SID, but in the case of a SID parameter only reports on the the accessPolicy for HEAD PID.</p>
</dd>
<dt>MN.synchronizationFailed(Identifier pid):</dt><dd><p>Inter-node communication should only use PIDs for identifying objects.</p>
</dd>
<dt>MN.replicate(Identifier id):</dt><dd><p>No changes in behavior. SystemMetadata object has changed structure so there is a change in signature.
Replication is based on the PID so that we can ensure content has not been corrupted.</p>
</dd>
<dt>MN.getReplica(Identifier id):</dt><dd><p>Can only make requests for PIDs so that checksum integrity can be verified.</p>
</dd>
<dt>MN.systemMetadataChanged(Identifier, serialVersion, dateSysMetaModified):</dt><dd><p>May be called on the MN if the CN infers an obsoletes relationship for a new PID based on a shared SID.
Identifier can be either a PID or a SID.
If a SID, the MN will fetch SystemMetadata from the CN using SID (which will return the HEAD PID SystemMetadata).</p>
</dd>
<dt>MN.listObjects(?identifier=XXX):</dt><dd><p>Returns an ObjectList like normal, but can be filtered by identifer (SID or PID).
If the Identifier is a PID, it returns just the single entry for that PID.
If the Identifier is a SID, it returns the objects (PIDs) of all objects that have that SID.</p>
</dd>
<dt>MN.view(Identifier id):</dt><dd><p>Can accept either PID or SID. If a PID, get the formated view for the specified version. If a SID, get the view for the HEAD PID.</p>
</dd>
<dt>MN.getPackage(Identifier id):</dt><dd><p>Can accept either PID or SID. If a PID, get the package of the specified version. If a SID, get the package of the HEAD PID.</p>
</dd>
<dt>MN.updateSystemMetadata(Identifier id, SystemMetadata newSysmeta):</dt><dd><dl class="simple">
<dt>Requires a PID. The SID can exist in the newSysmeta object. Since SID is immutable, the SID in the newSysmeta should match the current SID if it exists. If current system metadata doesn’t have a SID, the new SID can be one of the following cases:</dt><dd><ol class="arabic simple">
<li><p>The new SID is null (without a SID).</p></li>
<li><p>The new SID is a unique identifier which doesn’t exist in the system.</p></li>
<li><p>The new SID matches the SID in the system metadata of the object in the “obsoletes” value.</p></li>
<li><p>The new SID matches the SID in the system metadata of the object in the “obsoletedBy” value.</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="cn-api-method-changes">
<h3><a class="toc-backref" href="#id45">CN API method changes</a><a class="headerlink" href="#cn-api-method-changes" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>CN.get(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.describe(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.getSystemMetadata(Identifier id):</dt><dd><p>Behaves the same as MN.
N.B. This method can be used with a SID to locate the PID of the latest version which may be sufficient without implementing a
getHead() method.</p>
</dd>
<dt>CN.getChecksum(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.getLogRecords(?idFilter):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.create(Identifier pid, object, SystemMetadata):</dt><dd><dl class="simple">
<dt>Identifier must be PID and included in accompanying systemMetadata. SID may be included in accompanying systemMetadata if known at time of creation. The SID can be one of the following cases:</dt><dd><ol class="arabic simple">
<li><p>The SID is a unique identifier which doesn’t exist in the system.</p></li>
<li><p>The SID matches the SID in the system metadata of the object in the “obsoletes” value.</p></li>
<li><p>The SID matches the SID in the system metadata of the object in the “obsoletedBy” value.</p></li>
</ol>
</dd>
</dl>
</dd>
<dt>CN.registerSystemMetadata(Identifier pid, SystemMetadata sysmeta):</dt><dd><dl class="simple">
<dt>Requires a PID, allows a SID in the SystemMetadata. The SID can be one of the following cases:</dt><dd><ol class="arabic simple">
<li><p>The SID is a unique identifier which doesn’t exist in the system.</p></li>
<li><p>The SID matches the SID in the system metadata of the object in the “obsoletes” value.</p></li>
<li><p>The SID matches the SID in the system metadata of the object in the “obsoletedBy” value.</p></li>
</ol>
</dd>
</dl>
</dd>
<dt>CN.updateSystemMetadata(Identifier id, SystemMetadata newSysmeta):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.delete(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.archive(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.reserveIdentifier(Identifier id):</dt><dd><p>Accepts PID or SID values and treats them exactly the same.</p>
</dd>
<dt>CN.hasReservation(Identifier id):</dt><dd><p>Accepts PID or SID values and treats them exactly the same.</p>
</dd>
<dt>CN.resolve(Identifier):</dt><dd><p>If PID, resolve it.
If a SID, then resolve the HEAD PID.</p>
</dd>
<dt>CN.isAuthorized(Identifier id):</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.isNodeAuthorized(Identifier id):</dt><dd><p>Only accept PID since it is a replication related method. No behavior change.</p>
</dd>
<dt>CN.updateReplicationMetadata(Identifier id):</dt><dd><p>Only accept PID since it is a replication related method. No behavior change.</p>
</dd>
<dt>CN.deleteReplicationMetadata(Identifier id):</dt><dd><p>Only accept PID since it is a replication related method. No behavior change.</p>
</dd>
<dt>CN.setReplicationStatus(Identifier id):</dt><dd><p>Only accept PID since it is a replication related method. No behavior change.</p>
</dd>
<dt>CN.setReplicationPolicy():</dt><dd><p>Only accept PID since it is a replication related method. No behavior change.</p>
</dd>
<dt>CN.setRightsHolder():</dt><dd><p>Ownerships apply to particular revisions, not the entire chain.
If a SID is passed in to a method that affects one of these policies, the change is applied to the HEAD PID for that series.</p>
</dd>
<dt>CN.setAccessPolicy():</dt><dd><p>Policies apply to particular revisions, not the entire chain.
If a SID is passed in to a method that affects one of these policies, the change is applied to the HEAD PID for that series.</p>
</dd>
<dt>CN.setObsoletedBy(Identifier id, Identifier obsoletedByPid):</dt><dd><p>Only PIDs can be used when expressing obsolescence chain.</p>
</dd>
<dt>CN.view(Identifier id)</dt><dd><p>Behaves the same as MN</p>
</dd>
<dt>CN.listObjects(?identifier=XXX):</dt><dd><p>Behaves the same as MN</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="use-cases">
<h2><a class="toc-backref" href="#id46">Use Cases</a><a class="headerlink" href="#use-cases" title="Permalink to this headline">¶</a></h2>
<p>The use cases below organize the identified requirements related to mutable
content, with the most relevant use cases listed first.</p>
<div class="section" id="prioritized-goals">
<h3><a class="toc-backref" href="#id47">Prioritized goals</a><a class="headerlink" href="#prioritized-goals" title="Permalink to this headline">¶</a></h3>
<div class="section" id="data-preservation">
<h4><a class="toc-backref" href="#id48">1. Data preservation</a><a class="headerlink" href="#data-preservation" title="Permalink to this headline">¶</a></h4>
<p>Defined as activities that help ensure continued discoverability and usefulness
and usually in reference to metadata, not data.</p>
<ul class="simple">
<li><p>metadata adaptation / improvement</p></li>
<li><p>metadata correction</p></li>
<li><p>absent a “push” notification, users should be able to easily determine if they
have the most current version of something, and easily and quickly get it.</p></li>
</ul>
</div>
<div class="section" id="mutable-content-member-node-support">
<h4><a class="toc-backref" href="#id49">2. Mutable Content Member Node support</a><a class="headerlink" href="#mutable-content-member-node-support" title="Permalink to this headline">¶</a></h4>
<p>For institutions following a mutable content model:</p>
<ul class="simple">
<li><p>Provide a path forward for integrating into DataONE network.</p></li>
<li><p>Minimize the burden of adaptation to working with versioned content.</p></li>
<li><p>Allow use of their identifiers in DataONE in the context they are familiar with
(if their identifier always points to the latest, in DataONE it should too)</p></li>
<li><p>Options for maintaining past versions</p></li>
<li><p>Differentiating between incremental internal saves, vs. new revision.</p></li>
</ul>
</div>
<div class="section" id="citation-support">
<h4><a class="toc-backref" href="#id50">3. Citation support</a><a class="headerlink" href="#citation-support" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>avoid unnecessary costs associated with obtaining resolvable (e.g., DOIs) for each version</p></li>
<li><p>coordinating citation by a common identifier for citation tracking</p></li>
<li><p>ensuring that the cited object is the same when accessed as when it was originally used</p></li>
<li><p>ability to cite a version as well as the conceptual object</p></li>
</ul>
</div>
</div>
<div class="section" id="optional">
<h3><a class="toc-backref" href="#id51">Optional</a><a class="headerlink" href="#optional" title="Permalink to this headline">¶</a></h3>
<div class="section" id="support-for-frequently-changing-overwritten-data">
<h4><a class="toc-backref" href="#id52">4. Support for frequently changing / overwritten data</a><a class="headerlink" href="#support-for-frequently-changing-overwritten-data" title="Permalink to this headline">¶</a></h4>
<p>What is the best way to version mutable data that frequently changes but may or
not be used.  For example a “current time” object, replaced every minute, or
“current weather radar” that’s replaced every 3 hours.</p>
<ul class="simple">
<li><p>preserving every version could be very expensive for very little value</p></li>
<li><p>what mechanisms could be employed to minimize the overhead?</p></li>
</ul>
<p>The underlying dynamic here is the the rate of mutation vs. the rate of synchronization</p>
</div>
<div class="section" id="support-for-accumulating-datasets">
<h4><a class="toc-backref" href="#id53">5. Support for accumulating datasets</a><a class="headerlink" href="#support-for-accumulating-datasets" title="Permalink to this headline">¶</a></h4>
<p>This means supporting data objects that add records over time, either:</p>
<ul class="simple">
<li><p>within pre-defined bounds  e.g. “2013 year-to-date”  (the metadata could stay
the same, while data changes)</p></li>
<li><p>without pre-defined bounds e.g. “JGoodall primate observation log”?</p></li>
</ul>
</div>
<div class="section" id="support-for-mixed-metadata-data-objects">
<h4><a class="toc-backref" href="#id54">6. Support for mixed metadata/data objects</a><a class="headerlink" href="#support-for-mixed-metadata-data-objects" title="Permalink to this headline">¶</a></h4>
<p>Some formats combine data with metadata, for example netCDF, so allowing the
metadata to change without impacting the consistency assessment of the data itself.</p>
<ul class="simple">
<li><dl class="simple">
<dt>changes in the file are treated like any other change; they will be versioned,</dt><dd><p>but may be referenced using a seriesId</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="supporting-unrecorded-data-streams">
<h4><a class="toc-backref" href="#id55">7. Supporting ‘unrecorded’ data streams</a><a class="headerlink" href="#supporting-unrecorded-data-streams" title="Permalink to this headline">¶</a></h4>
<p>Mutable content can theoretically include things that are live feeds from
sensors, but are otherwise not captured.</p>
<p>This proposal does not accommodate streams unless they have discrete snapshots that can be referenced as part of
a seriesId.</p>
<ul class="simple">
<li><p>Should we allow identifiers to resolve to a URL that returns an input stream?</p></li>
<li><p>Can we prevent it?</p></li>
<li><p>Can we mark it as the user’s responsibility to do the mn.create?</p></li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
    <p class="logo"><a href="/">
      <img class="logo" src="../_static/dataone_logo.png" alt="Logo"/>
    </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Mutability of Content in DataONE</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#resolving-series-identifiers">Resolving Series Identifiers</a><ul>
<li><a class="reference internal" href="#case-1">Case 1</a></li>
<li><a class="reference internal" href="#case-2">Case 2</a></li>
<li><a class="reference internal" href="#case-3">Case 3</a></li>
<li><a class="reference internal" href="#case-4">Case 4</a></li>
<li><a class="reference internal" href="#case-5">Case 5</a></li>
<li><a class="reference internal" href="#case-6">Case 6</a></li>
<li><a class="reference internal" href="#case-7">Case 7</a></li>
<li><a class="reference internal" href="#case-8">Case 8</a></li>
<li><a class="reference internal" href="#case-9">Case 9</a></li>
<li><a class="reference internal" href="#case-10">Case 10</a></li>
<li><a class="reference internal" href="#case-11">Case 11</a></li>
<li><a class="reference internal" href="#case-12">Case 12</a></li>
<li><a class="reference internal" href="#case-13">Case 13</a></li>
<li><a class="reference internal" href="#case-14">Case 14</a></li>
<li><a class="reference internal" href="#case-15">Case 15</a></li>
<li><a class="reference internal" href="#case-16">Case 16</a></li>
<li><a class="reference internal" href="#case-17">Case 17</a></li>
<li><a class="reference internal" href="#case-18">Case 18</a></li>
<li><a class="reference internal" href="#case-19">Case 19</a></li>
</ul>
</li>
<li><a class="reference internal" href="#referencing-content-by-identifier">Referencing Content by Identifier</a></li>
<li><a class="reference internal" href="#assigning-identifiers">Assigning Identifiers</a></li>
<li><a class="reference internal" href="#limits-on-the-series">Limits on the Series</a></li>
<li><a class="reference internal" href="#requirements-on-member-node-implementations">Requirements on Member Node Implementations</a></li>
<li><a class="reference internal" href="#reassignment-of-authoritativemembernode-field-for-unhosted-versions">Reassignment of AuthoritativeMemberNode field for unhosted versions</a></li>
<li><a class="reference internal" href="#replication-of-unhosted-back-versions">Replication of unhosted back-versions</a></li>
<li><a class="reference internal" href="#synchronizing-content-from-mutable-member-nodes">Synchronizing Content from Mutable Member Nodes</a></li>
<li><a class="reference internal" href="#the-problem">The Problem</a></li>
<li><a class="reference internal" href="#proposal">Proposal</a></li>
<li><a class="reference internal" href="#the-series-identifier">The Series Identifier</a><ul>
<li><a class="reference internal" href="#semantics-of-current">Semantics of “Current”</a><ul>
<li><a class="reference internal" href="#version-storage">Version Storage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#version-preservation">Version preservation</a></li>
<li><a class="reference internal" href="#working-drafts-vs-repository-publishing">Working drafts vs. Repository publishing</a><ul>
<li><a class="reference internal" href="#types-of-mutable-objects">Types of Mutable Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accumulating-datasets">Accumulating datasets</a></li>
<li><a class="reference internal" href="#mixed-metadata-data-objects">Mixed metadata-data objects</a><ul>
<li><a class="reference internal" href="#retrieval-citation-support">Retrieval / Citation Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieval-vs-resolution">Retrieval vs. Resolution</a></li>
<li><a class="reference internal" href="#service-development-plans">Service development plans</a></li>
<li><a class="reference internal" href="#mn-api-method-changes">MN API method changes</a></li>
<li><a class="reference internal" href="#cn-api-method-changes">CN API method changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#use-cases">Use Cases</a><ul>
<li><a class="reference internal" href="#prioritized-goals">Prioritized goals</a><ul>
<li><a class="reference internal" href="#data-preservation">1. Data preservation</a></li>
<li><a class="reference internal" href="#mutable-content-member-node-support">2. Mutable Content Member Node support</a></li>
<li><a class="reference internal" href="#citation-support">3. Citation support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional">Optional</a><ul>
<li><a class="reference internal" href="#support-for-frequently-changing-overwritten-data">4. Support for frequently changing / overwritten data</a></li>
<li><a class="reference internal" href="#support-for-accumulating-datasets">5. Support for accumulating datasets</a></li>
<li><a class="reference internal" href="#support-for-mixed-metadata-data-objects">6. Support for mixed metadata/data objects</a></li>
<li><a class="reference internal" href="#supporting-unrecorded-data-streams">7. Supporting ‘unrecorded’ data streams</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation Overview</a><ul>
      <li>Previous: <a href="ReplicationOverview.html" title="previous chapter">Replication Overview</a></li>
      <li>Next: <a href="PIDs.html" title="next chapter">Identifiers in DataONE</a></li>
  </ul></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/design/ContentMutability.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      <div id="copyright">
      &copy; Copyright <a href="http://www.dataone.org">2009-2019, DataONE</a>.
        [ <a href="../_sources/design/ContentMutability.txt"
               rel="nofollow">Page Source</a> |
          <a href='https://redmine.dataone.org/projects/d1/repository/changes/documents/Projects/cicore/architecture/api-documentation/source/design/ContentMutability.txt'
            rel="nofollow">Revision History</a> ]&nbsp;&nbsp;
      </div>
      <div id="acknowledgement">
        <p>This material is based upon work supported by the National Science Foundation
          under Grant Numbers <a href="http://www.nsf.gov/awardsearch/showAward?AWD_ID=0830944">083094</a> and <a href="http://www.nsf.gov/awardsearch/showAward?AWD_ID=1430508">1430508</a>.</p>
        <p>Any opinions, findings, and conclusions or recommendations expressed in this
           material are those of the author(s) and do not necessarily reflect the views
           of the National Science Foundation.</p>
      </div>
    </div>
    <!--
    <hr />
     <div id="HCB_comment_box"><a href="http://www.htmlcommentbox.com">HTML Comment Box</a> is loading comments...</div>
     <link rel="stylesheet" type="text/css" href="_static/skin.css" />
     <script type="text/javascript" language="javascript" id="hcb">
     /*<! -*/
     (function()
     {s=document.createElement("script");
     s.setAttribute("type","text/javascript");
     s.setAttribute("src", "http://www.htmlcommentbox.com/jread?page="+escape((typeof hcb_user !== "undefined" && hcb_user.PAGE)||(""+window.location)).replace("+","%2B")+"&mod=%241%24wq1rdBcg%24Gg8J5iYSHJWwAJtlYu/yU."+"&opts=21407&num=10");
     if (typeof s!="undefined") document.getElementsByTagName("head")[0].appendChild(s);})();
      /* ->*/
     </script>
   -->
  </body>
</html>